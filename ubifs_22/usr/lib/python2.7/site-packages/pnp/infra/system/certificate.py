################################################################################
# Copyright (c) 2015-17 by Cisco Systems, Inc.
# All rights reserved.
#
# Author: Shaurin Desai <shaurdes@cisco.com>
################################################################################
"""Certificate Handler

This file provides an interface to handle certificates used to verify SSL
connections.

"""
import os
import shutil
import subprocess
from logging import getLogger

import pnp.infra.utils.pnp_constants as consts
from pnp.infra.utils.pnp_file_paths import filepaths

logger = getLogger(__name__)


def get_embedded_certificate(cert_file):
    """Returns the absolute path to the specified certificate file

    Args:
        cert_file (str): File name of embedded certificate.

    Returns:
        str: Absolute path to embedded certificate. Empty string if embedded
            certificate not found.

    """
    if cert_file not in consts.EMBEDDED_CERTS:
        logger.debug('Unsupported embedded certificate: %s', cert_file)
        return ''
    cert_path = os.path.join(consts.PNP_BASE_DIR, 'data', cert_file)
    if not os.path.isfile(cert_path):
        logger.error('Embedded certificate not found: %s', cert_file)
        return ''
    return cert_path


def get_certificates_location(cert_type='trustpoint', create_directory=True):
    """Returns the path to the directory containing the CA files needed for
    server authentication. Directory is created if it does not exist already.

    Args:
        cert_type (str, optional): Certificate type (value is either 'trustpool'
            or 'trustpoint'). Defaults to 'trustpoint'.
        create_directory (bool, optional): Determines whether or not the
            certificate directory should be created if it doesn't already exist.
            Defaults to True.

    Returns:
        str: File path to certificate directory. Empty string upon failure.

    """
    try:
        cert_dir = filepaths['certificates']['certs_dir']
    except KeyError:
        logger.exception("File paths config missing certificate directory")
        return ''
    if create_directory and not os.path.isdir(cert_dir):
        os.mkdir(cert_dir)
    if cert_type in ('trustpoint', 'trustpool'):
        cert_dir = os.path.join(cert_dir, cert_type)
    if create_directory and not os.path.isdir(cert_dir):
        os.mkdir(cert_dir)
    return cert_dir


def install_certificate(cert, label=''):
    """Interface for installing a certificate used for server authentication.

    Args:
        cert (str): File path to certificate.
        label (str, optional): Certificate identifier. Defaults to file name
            parsed from specified cert.

    Returns:
        str: Path to installed certificate if installation is successful. Empty
            string otherwise.

    """
    if not os.path.isfile(cert):
        logger.error('Failed to locate certificate to install')
        return ''
    certificate_directory = get_certificates_location('trustpoint')
    if label:
        install_path = os.path.join(certificate_directory, label)
    else:
        filename = os.path.basename(cert)
        install_path = os.path.join(certificate_directory, filename)
    try:
        shutil.move(cert, install_path)
    except (IOError, OSError):
        logger.exception("Failed to install certificate")
        return ''
    logger.debug('certificate successfully installed: %s', install_path)
    return install_path


def install_certificate_bundle(trustpool):
    """Interface for installing a Cisco Trustpool bundle used for server
    authentication.

    Args:
        trustpool (str): File path to certificate bundle

    Returns:
        str: Path to installed certificate bundle if installation is successful,
            empty string otherwise.

    """
    if not os.path.isfile(trustpool):
        logger.error('Failed to locate pkcs7 file')
        return ''
    certificate_directory = get_certificates_location('trustpool')
    filename = os.path.splitext(os.path.basename(trustpool))[0]
    cert_bundle = os.path.join(certificate_directory, filename + '.pem')
    # Verify trustpool bundle signature against Cisco Root CA
    # Trustpool .p7b must be converted to .pem before verifying
    bundle_pem = os.path.join(certificate_directory, 'tmp_pem')
    convert_args = ['openssl', 'pkcs7', '-inform', 'DER', '-outform', 'PEM',
                    '-print_certs', '-in', trustpool, '-out', bundle_pem]
    result = subprocess.call(convert_args)
    if result != 0:
        logger.error('Failed to verify Trustpool bundle signature')
        logger.debug('subprocess.call(convert_args) returned %d', result)
        return ''
    # Verify bundle signature against Cisco Root CA
    cisco_root = get_embedded_certificate(consts.CISCO_ROOT_CERT)
    verify_args = ['openssl', 'verify', '-CAfile', cisco_root, bundle_pem]
    result = subprocess.call(verify_args)
    if result != 0:
        logger.error('Failed to verify Trustpool bundle signature')
        logger.debug('subprocess.call(verify_args) returned %d', result)
        return ''
    # Remove temporary bundle pem file
    os.remove(bundle_pem)
    # Extract certificates from Trustpool body
    bundle_signer = get_embedded_certificate(consts.TRUSTPOOL_BUNDLE_SIGNER)
    if not os.path.isfile(bundle_signer):
        logger.debug('RootBundlerSigner.cer not found')
        logger.error('Unable to extract Trustpool')
        return ''
    bundle_body = os.path.join(certificate_directory, 'BundleBodyVerified.p7b')
    extract_args = ['openssl', 'cms', '-verify', '-noverify', '-inform', 'DER',
                    '-in', trustpool, '-outform', 'DER', '-out', bundle_body,
                    '-certfile', bundle_signer]
    result = subprocess.call(extract_args)
    if result != 0:
        logger.error('Failed to extract trustpool file')
        logger.debug('subprocess.call(step1_args) returned %d', result)
        return ''
    # PEM-encode extracted certificates
    encode_args = ['openssl', 'pkcs7', '-inform', 'DER', '-outform', 'PEM',
                   '-print_certs', '-in', bundle_body, '-out', cert_bundle]
    subproc = subprocess.Popen(encode_args, stdout=subprocess.PIPE,
                               stderr=subprocess.PIPE)
    output, err = subproc.communicate()
    result = subproc.poll()
    if result != 0:
        logger.error('Failed to encode extracted certs to pem')
        logger.error('subprocess.call(step2_args) returned %d', result)
        logger.error('subprocess output: %s; error: %s', output, err)
        return ''
    # Remove DER-encoded Trustpool certificates
    os.remove(bundle_body)
    if not os.path.isfile(cert_bundle):
        logger.error('Failed to create PEM-encoded trustpool file')
        return ''
    logger.debug('certificate bundle successfully installed: %s', cert_bundle)
    return cert_bundle


def uninstall_certificate(label):
    """Interface for uninstalling a certificate used for server authentication.
    The certificate to uninstall is identified by a label.

    Args:
        label (str): Label used to identify certificate to uninstall.

    Returns:
        bool: True upon successful uninstall, False otherwise.

    """
    # Do not attempt to create the certificate directory during certificate
    # uninstall. This helps running whitebox testing on platforms where the
    # certificate directory doesn't exist or can't be created, e.g. /run/certs
    certificate_directory = get_certificates_location('trustpoint',
                                                      create_directory=False)
    if not certificate_directory:
        return True
    cert = os.path.join(certificate_directory, label)
    logger.debug('Certificate to uninstall: %s', cert)
    try:
        os.remove(cert)
    except (IOError, OSError):
        logger.exception("Failed to uninstall certificate")
        return False
    return True


def uninstall_certificate_bundle(label):
    """Interface for uninstalling a certificate bundle used for server
    authentication. The certificate bundle to uninstall is identified by a
    label.

    Args:
        label (str): Label used to identify certificate bundle to uninstall.

    Returns:
        bool: True upon successful uninstall, False otherwise.

    """
    certificate_directory = get_certificates_location('trustpool',
                                                      create_directory=False)
    if not certificate_directory:
        return True
    bundle_label = label + '.pem'
    cert = os.path.join(certificate_directory, bundle_label)
    logger.debug('Certificate bundle to uninstall: %s', cert)
    try:
        os.remove(cert)
    except (IOError, OSError):
        logger.exception("Failed to uninstall certificate bundle")
        return False
    return True


def uninstall_certificate_bundles():
    """Interface for uninstalling all certificate bundles used for server
    authentication.

    Returns:
        bool: True upon successful uninstall, False otherwise.

    """
    bundle_dir = get_certificates_location('trustpool')
    bundle_list = os.listdir(bundle_dir)
    uninstall_result = True
    for bundle in bundle_list:
        logger.info('uninstalling bundle: %s', bundle)
        try:
            os.remove(os.path.join(bundle_dir, bundle))
        except (IOError, OSError):
            logger.exception("Failed to uninstall bundle: %s", bundle)
            uninstall_result = False
    return uninstall_result
