################################################################################
# Copyright (c) 2015-17 by Cisco Systems, Inc.
# All rights reserved.
#
# Author: Andrew Au <aau@cisco.com>
################################################################################
"""Network Interface Info

This is the interface utility code for querying a Linux platform for the info
of all its network interfaces present regardless of its type or interface
state/status. It leaves the necessary filtering to the caller over what or which
interfaces are wanted to be included.

"""
import ctypes
from ctypes import (POINTER, Structure, Union, c_byte, c_char_p, c_uint,
                    c_uint16, c_uint32, c_ushort, c_void_p, cast, get_errno,
                    pointer, util)
from logging import getLogger
from os import path
from socket import AF_INET, AF_INET6, inet_ntop

libc = ctypes.CDLL(util.find_library('c'))
logger = getLogger(__name__)


class IFFState(object):   # pylint: disable=too-few-public-methods
    """ Constant definitions of IFF (interface) states as in net/if.h
    """
    IFF_UP = 0x0001             # interface is up
    IFF_BROADCAST = 0x0002      # broadcast address valid
    IFF_DEBUG = 0x0004          # turn on debugging
    IFF_LOOPBACK = 0x0008       # is a loopback net
    IFF_POINTOPOINT = 0x0010    # interface is point-to-point link
    IFF_NOTRAILERS = 0x0020     # avoid use of trailers
    IFF_RUNNING = 0x0040        # resources allocated
    IFF_NOARP = 0x0080          # no address resolution protocol
    IFF_PROMISC = 0x0100        # receive all packets
    IFF_ALLMULTI = 0x0200       # receive all multicast packets
    IFF_OACTIVE = 0x0400        # transmission in progress
    IFF_SIMPLEX = 0x0800        # can't hear own transmissions
    IFF_LINK0 = 0x1000          # per link layer defined bit
    IFF_LINK1 = 0x2000          # per link layer defined bit
    IFF_LINK2 = 0x4000          # per link layer defined bit
    IFF_MULTICAST = 0x8000      # supports multicast

class _StructSockaddr(Structure):   # pylint: disable=too-few-public-methods
    """ Definition of data structure fields for a socket addr
    """
    _fields_ = [
        ('sa_family', c_ushort),
        ('sa_data', c_byte * 14),]

class _StructSockaddrIn(Structure):   # pylint: disable=too-few-public-methods
    """ Definition of data structure fields for an IPv4 socket addr
    """
    _fields_ = [
        ('sin_family', c_ushort),
        ('sin_port', c_uint16),
        ('sin_addr', c_byte * 4)]

class _StructSockaddrIn6(Structure):   # pylint: disable=too-few-public-methods
    """ Definition of data structure fields for an IPv6 socket addr
    """
    _fields_ = [
        ('sin6_family', c_ushort),
        ('sin6_port', c_uint16),
        ('sin6_flowinfo', c_uint32),
        ('sin6_addr', c_byte * 16),
        ('sin6_scope_id', c_uint32)]

class _StructIfaIfu(Union):   # pylint: disable=too-few-public-methods
    """ Definition of the fields in the union used by ifa_ifu that
    contains an interface's broadcast or point-to-point destination
    address as defined in the ifaddrs struct used by getifaddrs() in libc
    """
    _fields_ = [
        ('ifu_broadaddr', POINTER(_StructSockaddr)),
        ('ifu_dstaddr', POINTER(_StructSockaddr)),]

class _StructIfaddrs(Structure):   # pylint: disable=too-few-public-methods
    pass

# Definition of the fields in the ifaddrs structure in libc for use
# with the getifaddrs() function
_StructIfaddrs._fields_ = [   # pylint: disable=protected-access
    ('ifa_next', POINTER(_StructIfaddrs)),
    ('ifa_name', c_char_p),
    ('ifa_flags', c_uint),
    ('ifa_addr', POINTER(_StructSockaddr)),
    ('ifa_netmask', POINTER(_StructSockaddr)),
    ('ifa_ifu', _StructIfaIfu),
    ('ifa_data', c_void_p),]

def ifap_iter(ifap):
    """ Iterator for each interface record on the list generated by
    getifaddrs()
    """
    ifa = ifap.contents
    while True:
        yield ifa
        if not ifa.ifa_next:
            break
        ifa = ifa.ifa_next.contents

def get_ipfamily_addr(sa):
    """ Retrieve from the given socket addr object the addr of the addr
    family specified in it.

    Input: socket addr data structure
    Return: addr of the specified addr family if it's either IPv4 or IPv6
            None if otherwise
    """
    family = sa.sa_family
    addr = None

    # Retrieve the info from the structure contents pointed to
    if family == AF_INET:
        sa = cast(pointer(sa), POINTER(_StructSockaddrIn)).contents
        addr = inet_ntop(family, sa.sin_addr)
    elif family == AF_INET6:
        sa = cast(pointer(sa), POINTER(_StructSockaddrIn6)).contents
        addr = inet_ntop(family, sa.sin6_addr)

    return family, addr

def get_macaddr(intf_name):
    """ Retrieve the MAC addr of the given interface by name

    Input: intf_name - name of the interface which MAC addr is to be returned
    Return: MAC addr of this given name if found; 00:00:00:00:00:00 if otherwise
    """
    try:
        mac = open("/sys/class/net/" + intf_name + "/address").readline()
    except (IOError, EOFError):
        err_str = "MAC addr of " + intf_name + " unavailable"
        logger.error(err_str)
        mac = "00:00:00:00:00:00"

    return mac[0:17]

class NetInterface(object):   # pylint: disable=too-few-public-methods
    """ Class of network interfaces
    """
    def __init__(self, name, flags):
        self.name = name
        self.flags = flags
        self.addresses = {}
        self.macaddr = get_macaddr(name)
        self.type = None

    def get_netinfo(self):
        """This function retrieves the interface info of the NetInterface obj
        Input: none
        Return: netinfo - a dictionary in which the interface info are included
        """
        netinfo = {}
        netinfo['flags'] = self.flags
        netinfo['ipv4'] = self.addresses.get(AF_INET)
        netinfo['ipv6'] = self.addresses.get(AF_INET6)
        netinfo['macaddr'] = self.macaddr
        return netinfo

def compose_interface_dict(interface_dict):
    """ Formulate the interface info into a dictionary, which is what's
    returned back to the caller. This dictionary uses the interface name as
    the key, while the dictionary value is also a dictionary using the keys:
    type, status, ipv4, ipv6, macAddress.

    Input: interface_list - a list of interface info which 1st element is
                            the name, followed by the interface status
                            flags, IPv4 addr, IPv6 addr, MAC Address
    Return: a dictionary of the interface info retrieved
    """
    intf_list_dict = {}
    for intf_name, netintf in interface_dict.iteritems():
        netinfo = netintf.get_netinfo()
        type_path = "/sys/class/net/" + intf_name
        if 'virtual' in path.realpath(type_path):
            intf_type = 'logical'
        else:
            intf_type = 'physical'

        running_state_file = "/sys/class/net/" + intf_name + "/operstate"
        try:
            with file(running_state_file) as f:
                operstate = f.read()[0:-1]
        except (IOError, EOFError):
            err_str = "Linux operstate of " + intf_name + " unavailable"
            logger.error(err_str)
            operstate = "unknown"

        intf_dict = {}
        intf_dict = {'status': netinfo['flags'],
                     'operstate': operstate,
                     'type': intf_type,
                     'macAddress': netinfo['macaddr']}
        if netinfo['ipv4']:
            intf_dict['ipv4'] = netinfo['ipv4']
        if netinfo['ipv6']:
            intf_dict['ipv6'] = netinfo['ipv6']       #list of IPv6 addrs
        intf_list_dict[intf_name] = intf_dict

    return intf_list_dict

def retrieve_ifaddrs():
    """ Invoke getifaddrs() to retrieve all the network interfaces & fill
    the results into the pointed data structure ifap

    Return: ifap - a pointer to the ifaddrs structure in which all the
                   retrieved interface info are stored
            None - when getifaddrs() returns error
    """
    ifap = POINTER(_StructIfaddrs)()
    try:
        result = libc.getifaddrs(pointer(ifap))
        if result != 0:
            raise OSError(get_errno())
        del result
        return ifap
    except OSError:
        # OSError could be resulted from the getifaddrs() call which is
        # consumed here. As a result, an error log is generated and
        # None returned back to the caller
        err_str = "OSError: %d" + str(get_errno())
        logger.error(err_str)
        if ifap is not None:
            libc.freeifaddrs(ifap)
        return None

class InterfaceInfoDb(object):
    """ Query for the list of network interface info and populate them into
    the data structure ifap

    Return: object InterfaceInfoDb - upon successful interface info retrieval
    Raise: exception LookupError - upon failure in such retrieval, since this
                                   retrieval is before result filtering and
                                   some interface(s) is/are supposed to be
                                   found, while none has been
    """
    def __init__(self):
        self.db = {}
        ifap = retrieve_ifaddrs()
        if ifap is None:
            # Raise the exception LookupError back to the caller after the
            # retrieval attempt has failed
            err_str = "Failed to retrieve any interface info"
            logger.error(err_str)
            raise LookupError

        try:
            result_dict = {}
            for ifa in ifap_iter(ifap):
                name = ifa.ifa_name
                dict_value = result_dict.get(name)
                if not dict_value:
                    # Call NetInterface() to create & init this object with
                    # the given interface name & flags
                    # Its addrs will be retrieved by get_ipfamily_addr() below
                    # from the structure ifa.ifa_addr.contents being pointed to
                    dict_value = result_dict[name] \
                                 = NetInterface(name, ifa.ifa_flags)

                family, addr = get_ipfamily_addr(ifa.ifa_addr.contents)

                if addr:
                    if family == AF_INET6:
                        if AF_INET6 not in dict_value.addresses.keys():
                            #init the list for saving multiple IPv6 addrs
                            dict_value.addresses[AF_INET6] = []
                        dict_value.addresses[AF_INET6].append(addr)
                    else:
                        #for IPv4, the same intf name can have only 1 addr;
                        #secondary addr goes under a different intf name,
                        #e.g. eth0:1
                        dict_value.addresses[family] = addr

        except (KeyError, ValueError, StopIteration):
            # Raise the exception LookupError back to the caller after the
            # retrieval attempt has failed and generated either KeyError,
            # ValueError or StopIteration
            err_str = "Error in collecting interface info"
            logger.error(err_str)
            self.db = {}
            raise LookupError
        finally:
            libc.freeifaddrs(ifap)

        # Call compose_interface_dict() to compose the final dictionary to
        # be returned in which each interface info field is keyed: status,
        # type, ipv4, ipv6, macAddress...
        self.db = compose_interface_dict(result_dict)

    def get_keys(self):
        """ Return the # of elements present
        """
        return self.db.keys()

    def get_items(self):
        """ Return the resulting dictionary composed that stores all the
        interface info retrieved
        """
        return self.db
