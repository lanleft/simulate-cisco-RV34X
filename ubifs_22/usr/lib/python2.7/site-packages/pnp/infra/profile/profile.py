################################################################################
# Copyright (c) 2015-17 by Cisco Systems, Inc.
# All rights reserved.
#
# Author: Tai Pham <taipham@cisco.com>
################################################################################
"""PnP Profile

PnP Profile provides an interface for the PnP Agent to communicate with a PnP
Server. A profile will make calls to the Connection Manager and help the Agent
handle incoming PnP Service requests from the Server.

Todo:
    * Move stats tracking to another module.
    * Incorporate profile data currently tracked in pnp.agent global data dict.
    * Better profile naming in pnp_config

"""
import ConfigParser
import json
import os
from logging import getLogger
from time import gmtime, strftime, time

import pnp.infra.utils.pnp_constants as consts
from pnp.infra.errors import PnPConnError, PnPProfileError
from pnp.infra.network.connection_manager import ConnectionManager
from pnp.infra.system.user_auth import UserAuth
from pnp.infra.utils.pnp_file_paths import filepaths
from pnp.infra.utils.pnp_utils import read_pnp_config as utils_read_pnp_config


class Profile(object):
    """PNP profile contains profile data and method to access profile data"""

    _server_work_request = ''
    _server_work_response = ''
    _correlator = ''
    last_correlator = ''
    work_request_rcv = False
    work_response_rcv = False
    session_id = ''
    name = ''
    _udi = ''

    def __init__(self, conn_data, name_):
        """Initializes a PnP Profile.

        Args:
            conn_data (ConnectionInfo): Connection Info dictionary populated
                with PnP Server connectivity details
            name_ (str): PnP Profile name and identifier

        """
        self.name = name_
        self._conn_manager = ConnectionManager(conn_data)
        self.count = 0
        self._backoff = consts.BACKOFF_DEFAULT
        self._callback_after = consts.CALLBACK_AFTER_DEFAULT
        self._user_auth_required = UserAuth.is_auth_required()
        self.logger = getLogger('pnp.infra.Profile').getChild(self.name)
        # Refactor: status tracking to be moved elsewhere
        try:
            with open(filepaths['data']['job'], 'r') as f:
                self.requests_status = json.load(f)
        except IOError:
            pass
        try:
            if not os.path.exists(filepaths['data']['profile']):
                open(filepaths['data']['profile'], 'w').close()
            with open(filepaths['data']['profile'], 'r+') as f:
                try:
                    self.profile_status = json.load(f)
                except ValueError:
                    self.profile_status = dict()
                    self.profile_status['info'] = {}
                    self.profile_status['WR-Tracking'] = {}
                self.profile_status = dict()
                self.profile_status['info'] = {}
                self.profile_status['info']['Name'] = self.name
                self.profile_status['info']['CBType'] = 'DHCP'
                self.profile_status['info']['Node'] = 'visible'
                self.profile_status['info']['Primary-Path'] = 'pnp/WORK-REQUEST'
                primary_trans = conn_data.get('transport')
                self.profile_status['info']['Primary-Trans'] = primary_trans
                self.profile_status['info']['Backup-Trans'] = 'none'
                address = conn_data.get('address')
                self.profile_status['info']['address'] = address
                self.profile_status['info']['port'] = conn_data['port']
                self.profile_status['info']['current-backoff'] = self._backoff
                self.profile_status['WR-Tracking'] = {}
                self.profile_status['history'] = []
            with open(filepaths['data']['profile'], 'w') as f:
                f.write(json.dumps(self.profile_status))
        except IOError as e:
            print "profile.py " + str(e)

    @property
    def udi(self):
        """str: Unique Device Identifier in the following format:
        'PID:<PID>,VID:<VID>,SN:<SN>'
        """
        return self._udi

    @udi.setter
    def udi(self, udi_):  # pylint: disable=missing-docstring
        self._udi = udi_
        self.profile_status['info']['udi'] = self._udi

    @property
    def correlator(self):
        """str: Correlator is used to track and identify PnP Handshakes"""
        return self._correlator

    @correlator.setter
    def correlator(self, correlator_):  # pylint: disable=missing-docstring
        self._correlator = correlator_
        self.profile_status['WR-Tracking']['Last-Correlator'] \
            = self.last_correlator
        self.profile_status['WR-Tracking']['Current-Correlator'] \
            = self._correlator
        with open(filepaths['data']['profile'], 'w') as f:
            f.write(json.dumps(self.profile_status))

    def end_profile_current_request(self):
        """Reset profile data to start new request"""
        self.last_correlator = self._correlator
        self._correlator = ''
        self.work_request_rcv = False
        self.work_response_rcv = False

    @property
    def callback_after(self):
        """int: Time to wait between sending Work-Info requests to the server"""
        return self._callback_after

    @callback_after.setter
    def callback_after(self, callback_time):  # pylint: disable=missing-docstring
        if not callback_time or callback_time < 1:
            self._callback_after = consts.CALLBACK_AFTER_DEFAULT
        self._callback_after = callback_time

    @property
    def backoff(self):
        """int: Time to backoff from sending Work-Info requests to the server"""
        return self._backoff

    @backoff.setter
    def backoff(self, time_):  # pylint: disable=missing-docstring
        self._backoff = time_
        self.profile_status['info']['current-backoff'] = self._backoff
        with open(filepaths['data']['profile'], 'w') as f:
            f.write(json.dumps(self.profile_status))

    def send_work_info_request(self, work_request, **kwargs):
        """Sends a Work-Info Work-Request to the server. The server's response
        to the Work-Info request is stored in the 'server_work_request' property
        upon successful exchange.

        The default behavior for sending Work-Info requests: send a single
        work-info request. Upon failure, delay for 15 seconds.

        Args:
            work_request (str): Work-Info Work-Request XML payload
            **kwargs:
                attempts (int, optional): # connection attempts. Defaults to 1.
                delay (int, optional): Delay after failed attempt (seconds).
                    Default is 15 seconds.

        Raises:
            ProfileError: Upon failure to send Work-Info request.
        """
        try:
            resp = self._conn_manager.send_work_info_request(work_request,
                                                             **kwargs)
            self._server_work_request = resp
        except PnPConnError as err:
            self.logger.exception("Failed to send Work-Info request")
            raise PnPProfileError(err)
        self.count += 1
        history = format_pnp_history(time(), self.count, "0", "success",
                                     self._correlator,
                                     "XML Work-Req Service")
        self.profile_status['history'].append(history)
        with open(filepaths['data']['profile'], 'w') as f:
            f.write(json.dumps(self.profile_status))

    def send_work_response(self, work_response, **kwargs):
        """Sends a Work-Response to the server. The server's response to the
        Work-Response is stored in the 'server_work_response' property upon
        successful exchange.

        The default behavior for sending Work-Response requests: make 3 attempts
        to send Work-Response payload, with a 15 second delay between attempts.

        Raises:
            ProfileError: Upon failure to send Work-Response.
        """
        try:
            resp = self._conn_manager.send_work_response(work_response,
                                                         **kwargs)
            self._server_work_response = resp
        except PnPConnError as err:
            self.logger.exception("Failed to send Work-Response")
            raise PnPProfileError(err)
        self.count += 1
        history = format_pnp_history(time(), self.count, "0", "success",
                                     self._correlator,
                                     "XML Work-Res Service")
        self.profile_status['history'].append(history)
        with open(filepaths['data']['profile'], 'w') as f:
            f.write(json.dumps(self.profile_status))

    @property
    def server_work_request(self):
        """str: Returns the Work-Request XML payload sent by the Server"""
        return self._server_work_request

    @property
    def server_work_response(self):
        """str: Returns the Work-Response XML payload sent by the Server"""
        return self._server_work_response

    def mark_request_done(self, request, request_status):
        """Mark request done"""
        if request not in self.requests_status:
            self.requests_status[request] = {}
        self.requests_status[request]['status'] = request_status
        self.requests_status[request]['time'] = strftime("%H:%M:%S %b %d",
                                                         gmtime(time()))
        with open(filepaths['data']['job'], 'w') as f:
            f.write(json.dumps(self.requests_status))

    def mark_request_not_done(self, request):
        """Mark request not done"""
        if request not in self.requests_status:
            self.requests_status[request] = {}
        self.requests_status[request]['status'] = 3
        self.requests_status[request]['time'] = strftime("%H:%M:%S %b %d",
                                                         gmtime(time()))
        with open(filepaths['data']['job'], 'w') as f:
            f.write(json.dumps(self.requests_status))

    def is_auth_required(self):
        """Determines if user authentication is required. This can depend on the
        configuration state of the system.

        Modifies: self._user_auth_required

        Returns:
            bool: True if user authentication is required, False otherwise.

        """
        if not self._user_auth_required:
            self._user_auth_required = UserAuth.is_auth_required()
        return self._user_auth_required

    def set_auth_required(self):
        """Notifies platform that user authentication will be enforced by PnP.

        Modifies: self._user_auth_required

        Returns:
            bool: True if platform API was called successfully and User
                Authentication has been enabled, False otherwise.

        """
        self._user_auth_required = UserAuth.set_auth_required()
        return self._user_auth_required

    def update_conn_data(self):
        """Checks if profile configuration has been modified and updates if
        necessary.
        """
        conf = ConfigParser.SafeConfigParser()
        conf.read(filepaths['config']['pnp'])
        try:
            modified = conf.getboolean('Profile ' + self.name, 'modified')
        except ConfigParser.NoOptionError:
            self.logger.warning("Config file does not contain 'modified' option"
                                "in section 'Profile %s'", self.name)
            return
        if modified:
            self.logger.debug("Modified profile config found")
            self._conn_manager = ConnectionManager(utils_read_pnp_config())
            conf.set('Profile '+self.name, 'modified', 'false')
            with open(filepaths['config']['pnp'], 'w') as config_file:
                conf.write(config_file)


def format_pnp_history(_time, count, elapsed, status, correlator, service_name):
    """Returns string containing PnP History
    """
    template = ("T:{0}, Job {1}:{5}, Elapsed:{2} ms, Status: {3}, WorkReqCorr: "
                "{4}\n")
    return template.format(_time, count, elapsed, status, correlator,
                           service_name)
