################################################################################
# Copyright (c) 2015-17 by Cisco Systems, Inc.
# All rights reserved.
#
# Author: Tai Pham <taipham@cisco.com>
################################################################################
"""HTTP(S) Connection Client

HTTPConnClient is used to handle HTTP(S) connections. This class should only be
used through calls to ConnectionManager.

"""
import os
import socket
import time
import urllib2
from httplib import BadStatusLine as HttpBadStatusLine, HTTPConnection
from logging import getLogger
from ssl import CertificateError
from urllib import urlretrieve

import pnp.infra.network.security as security
import pnp.infra.utils.pnp_constants as consts
from pnp.infra.errors import PnPConnError
from pnp.infra.network.connection_client import ConnectionClient
from pnp.infra.network.vrf import VRF
from pnp.infra.system.certificate import (get_certificates_location,
                                          install_certificate_bundle)
from pnp.infra.utils.pnp_utils import (is_valid_ipv4_address,
                                       is_valid_ipv6_address)


class HTTPConnClient(ConnectionClient):
    """HTTP connection client module use to handle http/https connection
    """

    logger = getLogger('pnp.infra.network.HTTPConnClient')

    def __init__(self, conn_data):
        """Initialize HTTP connection client.

        Args:
            conn_data (ConnectionInfo): Connection data required to connect
                to Server

        """
        super(HTTPConnClient, self).__init__(conn_data)
        if not self._validate_conn_data(conn_data):
            self.logger.debug('conn_data invalid for HTTPConnClient')
        self.transport = conn_data['transport']
        self.address = conn_data['address']
        if not self.address_type:
            self.address_type = conn_data['address_type']
        if self.transport == consts.PNP_TRANSTYPE_HTTPS:
            default_port = 443
        else:
            default_port = 80
        self.port = conn_data.get('port', default_port)
        self.cafile = conn_data['cafile']
        if self.cafile and self.transport == consts.PNP_TRANSTYPE_HTTPS:
            self.ctx = security.load_csdl_ssl_context(self.cafile)
        else:
            self.ctx = None

    def _validate_conn_data(self, conn_data):
        """Validates that input _conn_data contains connection data that are
        supported by the HttpConnClient.

        Args:
            conn_data (ConnectionInfo): connection data

        Returns:
            bool: True, if conn_data is supported by HTTPConnClient. False,
                otherwise.

        """
        valid = True
        self.logger.debug('conn_data: %s', conn_data)
        try:
            if conn_data['transport'] not in ('http', 'https'):
                valid = False
                self.logger.debug("conn_data transport protocol unsupported")
            address = conn_data['address']
            if not address:
                valid = False
                self.logger.debug("conn_data missing an address (ip or host)")
            else:
                if is_valid_ipv4_address(address):
                    self.address_type = consts.PNP_ADDRTYPE_IPV4
                elif is_valid_ipv6_address(address):
                    self.address_type = consts.PNP_ADDRTYPE_IPV6
                else:
                    self.address_type = consts.PNP_ADDRTYPE_HOST
                valid = True
        except KeyError as err:
            self.logger.debug(str(err))
            valid = False
        return valid

    def _send_request_helper(self, request_data, request_url):
        """Internal helper function to send a request to the server.

        Args:
            request_data (str): PnP XML payload
            request_url (str): URI to send

        Returns:
            file: file-like object with 3 additional methods:
                geturl(): returns URL of resource retrieved
                info(): returns the meta-info of the page (mimetools.Message)
                getcode(): returns the HTTP status code of the response

        Raises:
            URLError: on connection errors

        """
        if self.address_type == consts.PNP_ADDRTYPE_IPV6:
            url = '%s://[%s]:%s/%s' % (self.transport, self.address, self.port,
                                       request_url)
        else:
            url = '%s://%s:%s/%s' % (self.transport, self.address, self.port,
                                     request_url)
        VRF.set_vrf()
        if not request_data:
            # hello GET request
            req = urllib2.Request(url=url)
        else:
            req = urllib2.Request(url=url, data=request_data)
            req.add_header('Content-Type', 'text/xml')
            req.add_header('charset', 'utf8')
            req.add_header('Accept', 'application/xml, application/soap+xml, '
                           'application/dime, multipart/related, '
                           'text/*')
        self.logger.debug("PNP requests with url: " + url)

        if self.transport == consts.PNP_TRANSTYPE_HTTPS:
            f = urllib2.urlopen(req, context=self.ctx, timeout=30)
        else:
            f = urllib2.urlopen(req, timeout=5)
        return f

    def send_hello_request(self, hello_request='', **kwargs):
        """Sends a pnp HELLO request to the server. This is an HTTP(S) request
        without an XML payload. The URI /pnp/HELLO is used.

        The default behavior for HELLO requests: 3 attempts, with a 5 second
        delay between attempts.

        Args:
            hello_request (str, optional): Request data to be sent with HELLO.
                Defaults to empty string (no payload is needed for HELLO).
            **kwargs:
                attempts (int, optional): # of connection tries. Default is 3.
                delay (int, optional): Delay between attempts (seconds). Default
                    is 5.

        Returns:
            int: HTTP status code of the HELLO response. 0 if HELLO failed.

        """
        attempts = kwargs.get('attempts', 3)
        delay = kwargs.get('delay', 5)
        for _ in xrange(attempts):
            try:
                response = self._send_request_helper(hello_request, "pnp/HELLO")
                if hasattr(response, 'getcode'):
                    return response.getcode()
                else:
                    self.logger.debug("HELLO response has no status code")
            except (IOError, urllib2.URLError, urllib2.HTTPError,
                    HttpBadStatusLine, CertificateError):
                self.logger.exception("HELLO failed")
                time.sleep(delay)
        return 0

    def send_hello_request_response(self, hello_request='', **kwargs):
        """Sends a pnp HELLO request to the server. This is an HTTP(S) request
        without an XML payload. The URI /pnp/HELLO is used.

        The default behavior for HELLO requests: 3 attempts, with a 5 second
        delay between attempts.

        Args:
            hello_request (str, optional): Request data to be sent with HELLO.
                Defaults to empty string (no payload is needed for HELLO).
            **kwargs:
                attempts (int, optional): # of connection tries. Default is 3.
                delay (int, optional): Delay between attempts (seconds). Default
                    is 5.

        Returns:
            dict: HTTP status code of the HELLO response. 0 if HELLO failed.

        """
        attempts = kwargs.get('attempts', 3)
        delay = kwargs.get('delay', 5)
        for _ in xrange(attempts):
            try:
                response = self._send_request_helper(hello_request, "pnp/HELLO")
                if hasattr(response, 'getcode'):
                    response_dict = {'code': response.getcode(),
                                     'clock': response.info()['date']}
                    return response_dict
                else:
                    self.logger.debug("HELLO response has no status code")
            except (IOError, urllib2.URLError, urllib2.HTTPError,
                    HttpBadStatusLine, CertificateError):
                self.logger.exception("HELLO failed")
                time.sleep(delay)
        return None

    # Refactor: move retry logic to profile.send_work_info_request
    def send_work_info_request(self, work_request, **kwargs):
        """Sends a Work-Info Work-Request to the server. This is an HTTP(s)
        request with an XML payload. The URI /pnp/WORK-REQUEST is used.

        The default behavior for sending Work-Info requests: send a single
        work-info request. Upon failure, delay for 15 seconds.

        Args:
            work_request (str): Work-Info Work-Request XML payload
            **kwargs:
                attempts (int, optional): # connection attempts. Defaults to 1.
                delay (int, optional): Delay after failed attempt (seconds).
                    Default is 15 seconds.

        Returns:
            str: Work-Request XML payload sent by Server in response to
                Work-Info request. Empty string is possible if server responds
                without an XML payload.

        Raises:
            PnPConnError: Upon failure to send Work-Info Work-Request.

        """
        attempts = kwargs.get('attempts', 1)
        delay = kwargs.get('delay', 15)
        for _ in xrange(attempts):
            try:
                resp = self._send_request_helper(work_request,
                                                 "pnp/WORK-REQUEST")
                return resp.read()
            except (IOError, HttpBadStatusLine, urllib2.URLError,
                    urllib2.HTTPError, CertificateError):
                err_msg = "Retrying Work-Info Request in %d seconds..." % delay
                self.logger.exception(err_msg)
                time.sleep(delay)
        raise PnPConnError("Work-Info request failed to send")

    # Refactor: move retry logic to profile.send_work_response
    def send_work_response(self, work_response, **kwargs):
        """Sends a Work-Response to the server. This is an HTTP(s) request with
        an XML payload. The URI /pnp/WORK-RESPONSE is used.

        The default behavior for sending Work-Response requests: make 3 attempts
        to send Work-Response payload, with a 15 second delay between attempts.

        Args:
            work_response (str): Work-Response XML payload
            **kwargs:
                attempts (int, optional): # connection attempts. Defaults to 3.
                delay (int, optional): Delay after failed attempt (seconds).
                    Default is 15 seconds.

        Returns:
            str: Work-Response XML payload sent by Server in response to Agent.
                Empty string is possible if server responds without an XML
                payload.

        Raises:
            PnPConnError: Upon failure to send Work-Response.

        """
        attempts = kwargs.get('attempts', 3)
        delay = kwargs.get('delay', 15)
        for _ in xrange(attempts):
            try:
                resp = self._send_request_helper(work_response,
                                                 "pnp/WORK-RESPONSE")
                return resp.read()
            except (IOError, HttpBadStatusLine, urllib2.URLError,
                    urllib2.HTTPError, CertificateError):
                err_msg = "Retrying Work-Response in %d seconds..." % delay
                self.logger.exception(err_msg)
                time.sleep(delay)
        raise PnPConnError("Work-Response Request failed to send")

    def is_valid(self, skip_hello=False):
        """Validates connection data through HELLO work request. A Trustpool
        bundle will be downloaded, if required to send HELLO over HTTPS without
        an available CA file.

        Args:
            skip_hello (bool, optional): If true, connection data validation
                will skip trying to send a HELLO message to the PnP Server.
                Defaults to False (HELLO is sent).

        Returns:
            bool: True if PnP Server responds to HELLO request with 200, False
                otherwise.

        """
        if self.conn_data['transport'] == consts.PNP_TRANSTYPE_HTTPS:
            if not self.conn_data['cafile']:
                if not self._download_infosec_cert_bundle():
                    return False
            if skip_hello:
                return True
            response_ret_code = self.send_hello_request()
        else:
            if skip_hello:
                return True
            response_ret_code = self.send_hello_request()
        # Validate connection by checking for HTTP Status Code (200)
        if response_ret_code == 200:
            return True
        else:
            return False

    def is_valid_set_clock(self):
        """Validates connection data through HELLO work request. A Trustpool
        bundle will be downloaded, if required to send HELLO over HTTPS without
        an available CA file.

        Returns:
            dict: : A dict with "code" & clock if PnP Server HELLO response.

        """
        if self.conn_data['transport'] == consts.PNP_TRANSTYPE_HTTPS:
            if not self.conn_data['cafile']:
                if not self._download_infosec_cert_bundle():
                    return None
        return self.send_hello_request_response()

    def _download_infosec_cert_bundle(self):
        """Download infosec certificate bundle using HTTP to download
        certificate bundle to certs directory.

        Returns:
            bool: True upon successful download and installation of Trustpool,
                False otherwise.

        Raises:
            IOError: Raised for certificate bundle download failure due to I/O
                related reason.
            CertificateError: Raised for unexpected HTTPS Trustpool download
                location.

        """
        certificate_directory = get_certificates_location()
        cert_url = self.conn_data['trustpool']
        if cert_url:
            file_name = cert_url.split('/')[-1]
            discovery_type = self.conn_data.get('discovery-type', '')
            if discovery_type:
                discovery_type += "_"
            cert_path = os.path.join(certificate_directory,
                                     discovery_type + file_name)
            try:
                VRF.set_vrf()
                urlretrieve(cert_url, cert_path)
                install_path = install_certificate_bundle(cert_path)
                if os.path.isfile(cert_path):
                    os.remove(cert_path)
                if install_path:
                    self.cafile = self.conn_data['cafile'] = install_path
                    self.ctx = security.load_csdl_ssl_context(self.cafile)
                    return True
            except IOError as err:
                self.logger.debug('Failed to download cert bundle: %s', err)
                return False
            except CertificateError as err:
                self.logger.debug('Failed to download cert bundle due to'
                                  'certificate error: %s', err)
                return False
        return False


def send_http_head(server_ip):
    """This function sends an HTTP HEAD msg to the server at the given IP
    address.
    Note that for better capability to get the clock from the HTTP HEAD
    Response's header, different library APIs are used for IPv4 & IPv6.

    Args:
        server_ip (str): the IP addr to which an HTTP HEAD is to be sent

    Returns:
        str: the server's system clock if it's present in the HTTP HEAD respone,
            empty string otherwise.

    """
    retry_num = retry_sleep = 2
    for attempt_num in xrange(retry_num):
        date_result = _send_http_head_msg(server_ip)
        if date_result:
            return date_result
        getLogger(__name__).debug("Sleep for %d seconds before HTTP HEAD retry "
                                  "#%d", retry_sleep, attempt_num)
        time.sleep(retry_sleep)
    return ''


def _send_http_head_msg(server_ip):
    """This function sends an HTTP HEAD msg to the server at the give address.

    Args:
        server_ip (str): the IP address to which an HTTP HEAD is to be sent

    Returns:
        str: server's system clock if it's present in the HTTP HEAD response,
            None otherwise.

    """
    logger = getLogger(__name__)
    conn = HTTPConnection(server_ip, 80, timeout=10)
    try:
        logger.debug("sending HTTP HEAD to server addr: %s", server_ip)
        conn.request("HEAD", "/pnp/HELLO")
        resp = conn.getresponse()
    except (socket.timeout, IOError):
        logger.debug("unable to send HTTP HEAD to server addr: %s", server_ip)
        return None
    if not resp:
        return None
    sys_date = resp.getheader('date')
    logger.debug("HTTP HEAD Response status: %s; reason: %s", resp.status,
                 resp.reason)
    if sys_date:
        logger.debug("HTTP HEAD Response's clock is %s", sys_date)
    return sys_date

