################################################################################
# Copyright (c) 2015-17 by Cisco Systems, Inc.
# All rights reserved.
#
# Author: Shaurin Desai <shaurdes@cisco.com>
################################################################################
"""Connection Client and Info

ConnectionClient provides base methods which inheriting class should override.

ConnectionInfo provides an interface for PnP Connection information that will be
consumed by a ConnectionClient.

"""
from abc import ABCMeta, abstractmethod


class ConnectionClient(object):
    """Connection Client ABCMeta Class"""
    __metaclass__ = ABCMeta

    @abstractmethod
    def __init__(self, conn_data):
        if not isinstance(conn_data, ConnectionInfo):
            raise TypeError("Expected type 'ConnectionInfo', received %s" %
                            type(conn_data))
        self.conn_data = conn_data

    @abstractmethod
    def _validate_conn_data(self, conn_data):
        """Validates _conn_data is supported by connection client.
        """
        raise NotImplementedError()

    @abstractmethod
    def send_work_info_request(self, work_request):
        """Send a Work-Info Request to the server.
        """
        raise NotImplementedError()

    @abstractmethod
    def send_work_response(self, work_response):
        """Send a Work-Response to the server.
        """
        raise NotImplementedError()


class ConnectionInfo(dict):
    """Connection information storage with dictionary-interface

    Case insensitive key access. Returns None if key not found. Supports truth
    value testing.
    """
    supported_keys = ('transport', 'address', 'address_type', 'port',
                      'cafile', 'trustpool', 'ntp', 'discovery_type',
                      'user', 'password', 'preferred_protocol')

    def __init__(self, **kwargs):
        tuples = [('transport', kwargs.get('transport')),
                  ('address', kwargs.get('address')),
                  ('address_type', kwargs.get('address_type')),
                  ('port', kwargs.get('port')),
                  ('cafile', kwargs.get('cafile')),
                  ('trustpool', kwargs.get('trustpool')),
                  ('ntp', kwargs.get('ntp')),
                  ('discovery_type', kwargs.get('discovery_type')),
                  ('created_by', kwargs.get('created_by')),
                  ('user', kwargs.get('user')),
                  ('password', kwargs.get('password')),
                  ('preferred_protocol', kwargs.get('preferred_protocol'))]
        dict.__init__(self, tuples)

    def __setitem__(self, key, value):
        if key.lower() not in self.supported_keys:
            err_msg = "Unsupported key provided: %s; must be one of: %s"
            raise ValueError(err_msg % (key, ', '.join(self.supported_keys)))
        dict.__setitem__(self, key.lower(), value)

    def __getitem__(self, key):
        return dict.__getitem__(self, key.lower())

    def __missing__(self, key):
        if key not in self.supported_keys:
            raise KeyError(key)
        return None

    def __nonzero__(self):
        return any(value for value in dict.values(self))

    def __str__(self):
        out_str = ("Connection Info:\n"
                   "Transport: {conn[transport]}\n"
                   "Address: {conn[address]}\n"
                   "Port: {conn[port]}\n"
                   "CA File: {conn[cafile]}")
        return out_str.format(conn=self)

    def get(self, key, default=None):
        """Override get to support regular dict.get(...) call behavior. Required
        due to already populated key-values for supported keys.
        """
        value = dict.get(self, key.lower())
        if value is None:
            return default
        else:
            return value

