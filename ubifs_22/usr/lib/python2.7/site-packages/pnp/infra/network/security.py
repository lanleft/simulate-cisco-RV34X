################################################################################
# Copyright (c) 2015-17 by Cisco Systems, Inc.
# All rights reserved.
#
# Author: Shaurin Desai <shaurdes@cisco.com>
################################################################################
"""Network Security

This file contains functions and constants for security purposes. The values
used in this file vary across PnP Platforms, but should all abide by the Cisco
Product Security Baseline.

Todo:
    * Fix IP Address comparison made in _match_hostname_ip for IP Address
        strings in order to support matching IP Addresses represented in
        different representation/notations (i.e. '2001:420:54ff:4::431:19'
        should match against the equivalent '2001:420:54FF:4:0:0:431:19').
        Python 3.3 has the ipaddress library, so a similar solution should be
        used here.

    * Enhance SSL Context to load client certificate that server can use to
        authenticate the device. This can be done adding the call
        ssl_context.load_cert_chain() to load_csdl_ssl_context().

"""
import os
import socket
import ssl
from logging import getLogger

import pnp.infra.utils.pnp_constants as consts
from pnp.infra.system.certificate import get_certificates_location


def load_csdl_ssl_context(cafile_='', default_certs=False, trustpool=False):
    """Returns SSLContext object initialized to meet CSDL standards.

    Args:
        cafile_ (str, optional): Path to CA file containing PEM encoded cert(s).
            Defaults to empty string.
        default_certs (bool, optional): Load default OpenSSL certificates.
            Defaults to False.
        trustpool (bool, optional): Load an existing Trustpool bundle. Defaults
            to False.

    Returns:
        SSLContext: SSL Context loaded with requested certificates.

    """
    # Important to overload ssl.match_hostname in order support verifying the
    # identity of HTTPS server's certificate through the IP address in the
    # Subject Alternate Name field
    ssl.match_hostname = _match_hostname_ip
    ssl_context = ssl.SSLContext(consts.CSDL_SSL_PROTOCOL)
    ssl_context.verify_mode = ssl.CERT_REQUIRED
    # Set hostname verification during TLS handshake
    ssl_context.check_hostname = consts.CSDL_SSL_CHECK_HOSTNAME
    # Set CSDL approved ciphers in OpenSSL cipher list format
    ssl_context.set_ciphers(':'.join(consts.CSDL_CIPHERS))
    if cafile_ == 'default' or default_certs or consts.DEFAULT_CERTS_ENABLED:
        ssl_context.load_default_certs(ssl.Purpose.SERVER_AUTH)
    if trustpool:
        trustpool_path = get_certificates_location('trustpool')
        if os.path.isfile(os.path.join(trustpool_path, 'trustpool.pem')):
            ssl_context.load_verify_locations(trustpool_path)
    try:
        if cafile_:
            ssl_context.load_verify_locations(cafile=cafile_)
    except (ssl.SSLError, IOError, TypeError):
        if cafile_ != 'default':
            getLogger(__name__).exception("Failed to load configured cafile")
    return ssl_context


def _match_hostname_ip(cert, hostname):
    """This function is copied from ssl.match_hostname available in Python 2.7.9
    and has been extended to support server identity verification through
    IP Address in the subjectAltName field of cert. Verify that *cert* (in
    decoded format as returned by SSLSocket.getpeercert()) matches the
    *hostname*.  RFC 2818 and RFC 6125 rules are followed, but IP addresses are
    not accepted for *hostname*.

    CertificateError is raised on failure. On success, the function returns
    nothing.
    """
    if not cert:
        raise ValueError("empty or no certificate, match_hostname needs a "
                         "SSL socket or SSL context with either "
                         "CERT_OPTIONAL or CERT_REQUIRED")
    dnsnames = []
    san = cert.get('subjectAltName', ())
    for key, value in san:
        if key == 'DNS':
            if ssl._dnsname_match(value, hostname):  # pylint: disable=protected-access
                return
            elif hostname.endswith('.'):  # don't enforce trailing-dot in FQDN
                if ssl._dnsname_match(value, hostname[:-1]):  # pylint: disable=protected-access
                    return
            dnsnames.append(value)
        # PNP SPECIFIC CODE STARTS HERE
        elif key == 'IP Address':
            # Enhancement: if _ip_address_match(value, hostname): return
            if _ssl_ip_address_match(value, hostname):
                return
            dnsnames.append(value)
        # PNP SPECIFIC CODE ENDS HERE
    if not dnsnames:
        # The subject is only checked when there is no dNSName entry
        # in subjectAltName
        for sub in cert.get('subject', ()):
            for key, value in sub:
                if key == 'commonName':
                    if ssl._dnsname_match(value, hostname):  # pylint: disable=protected-access
                        return
                    dnsnames.append(value)
    if len(dnsnames) > 1:
        raise ssl.CertificateError("hostname %r doesn't match either of %s" %
                                   (hostname, ', '.join(map(repr, dnsnames))))  # pylint: disable=bad-builtin
    elif len(dnsnames) == 1:
        raise ssl.CertificateError("hostname %r doesn't match %r" %
                                   (hostname, dnsnames[0]))
    else:
        raise ssl.CertificateError("no appropriate commonName or subjectAltName"
                                   " fields were found")


def _ssl_ip_address_match(value, ip_address):
    """Retruns True if ip_address matches value"""
    # Remove any extra whitespace characters from cert value
    value = value.strip()
    # Determine ip_address protocol version and convert to packed, binary format
    address_family = socket.AF_INET
    try:
        binary_ip_address = socket.inet_aton(ip_address)
    except socket.error:
        address_family = socket.AF_INET6
        try:
            binary_ip_address = socket.inet_pton(address_family, ip_address)
        except socket.error:
            # ip_address is neither IPv6 nor IPv4
            return False
    # Convert value to packed, binary format and enforce address family
    try:
        binary_value = socket.inet_pton(address_family, value)
    except socket.error:
        return False
    # Compare the two addresses after converting each to packed, binary format
    return binary_value == binary_ip_address

