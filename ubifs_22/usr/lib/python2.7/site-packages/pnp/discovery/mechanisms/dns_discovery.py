################################################################################
# Copyright (c) 2015-17 by Cisco Systems, Inc.
# All rights reserved.
#
# Author: Shaurin Desai <shaurdes@cisco.com>
################################################################################
"""DNS Discovery through option domain-name from DHCP lease

The entry point for this PnP Discovery mechanism is the method: dns_discovery.
This discovery mechanism requires that the Lease Parser API has been implemented
and is available from the pnp_platform library.

Todo:
    * Enhance NTP syncing behavior to make DNS Discovery quicker

"""
from logging import getLogger

import pnp.infra.utils.pnp_constants as consts
from pnp.discovery.infra.errors import DiscoveryAPIError
from pnp.infra.network.connection_client import ConnectionInfo
from pnp.infra.network.connection_manager import ConnectionManager
from pnp.infra.network.resolve import timed_url_resolver
from pnp.infra.system.certificate import uninstall_certificate_bundle
from pnp.infra.system.clock_sync import ClockSync
from pnp.infra.utils.pnp_utils import set_ipv_valid_check_func

# Platform-Dependent import. If unavailable, DNS Discovery will fail.
try:
    from pnp.discovery.infra.lease_parser import get_option_strings
except DiscoveryAPIError:
    pass

logger = getLogger(__name__)


def dns_discovery(protocol=consts.PNP_ADDRTYPE_IPV4):
    """Uses domain names from DHCP option domain-name to discover PnP Server.

    Args:
        protocol (str, optional): Preferred DHCP protocol ('ipv4' or 'ipv6').
            Defaults to 'ipv4'.

    Returns:
        ConnectionInfo: PnP Server connection information extracted from the
            first validated option string

    """
    domain_strings = get_option_strings('domain-name', protocol)
    logger.debug("Domain names found: %s", ', '.join(domain_strings))
    # Find PnP server location pointer in domain
    for domain_name in domain_strings:
        conn_info = _find_pnp_server(domain_name, protocol)
        if conn_info:
            return conn_info
    logger.debug("DNS Discovery failed")

def _is_ca_file_present(conn_data):
    """Returns true if ca file is downloaded
    Args:
        ConnectionInfo: PnP Server connection information
    Returns:
        True if file location present
        False if location is None
    """
    if conn_data['cafile']:
        return True
    else:
        return False

def _find_pnp_server(domain_name, ip_type=consts.PNP_ADDRTYPE_IPV4):
    """Searches for PnP server location within provided domain name using
    specified IP version.

    Args:
        domain_name (str): domain-name string extracted from DHCP Offer
        ip_type (str): Preferred protocol for FQDN resolution ('ipv4' or
            'ipv6'). Defaults to 'ipv4'.

    Returns:
        ConnectionInfo: PnP Server connection information found with
            domain_name.
        None: Upon failure.

    """
    pnpserver = 'pnpserver.{domain}'.format(domain=domain_name)
    # HTTPS based Discovery
    bundle_template = 'http://pnpserver.{domain}/ca/trustpool'
    if domain_name.endswith('.'):
        # exclude the ending '.' in domain_name to avoid having double dot
        ca_download_url = bundle_template.format(domain=domain_name[:-1])
    else:
        ca_download_url = bundle_template.format(domain=domain_name)
    logger.debug("Trustpool URL is %s", ca_download_url)

    #Try connection with server FQDN before resolving to IP.
    logger.debug("Trying HTTPS discovery through %s", pnpserver)
    https_conn_info = ConnectionInfo(transport=consts.PNP_TRANSTYPE_HTTPS,
                                     address=pnpserver,
                                     port=443,
                                     trustpool=ca_download_url,
                                     discovery_type='dns')

    # If FQDN connection is not valid fall back to connection with IP address
    if not ConnectionManager(https_conn_info).is_valid():
        if _is_ca_file_present(https_conn_info):
            resolved_addrs = timed_url_resolver(pnpserver,
                                                consts.DNS_URL_RESOLVER_TIMER,
                                                ip_type)
            is_valid_check = set_ipv_valid_check_func(ip_type)
            pnpserver_ip = None
            for addr in resolved_addrs:
                if is_valid_check(addr):
                    pnpserver_ip = addr
                    break
            if not pnpserver_ip:
                logger.debug("Failed to resolve server FQDN %s", pnpserver)
                return None
            logger.debug("Server FQDN %s resolves to %s", pnpserver,
                         pnpserver_ip)
            logger.debug("Trying HTTPS discovery through %s", pnpserver_ip)
            https_conn_info = ConnectionInfo(transport=consts.
                                             PNP_TRANSTYPE_HTTPS,
                                             address=pnpserver_ip,
                                             port=443,
                                             trustpool=ca_download_url,
                                             discovery_type='dns')
         # Try sending HELLO over HTTPS else try connection with IP address
            if ConnectionManager(https_conn_info).is_valid():
                return https_conn_info
    else:
        return https_conn_info

    # Try to sync system time with NTP servers
    if domain_name.endswith('.'):
        # exclude the ending '.' in domain_name to avoid having double dot
        pnp_ntp = 'pnpntpserver.{domain}.'.format(domain=domain_name[:-1])
    else:
        pnp_ntp = 'pnpntpserver.{domain}.'.format(domain=domain_name)
    clock_synced = False
    try:
        clock_synced = ClockSync.set_ntp_server(pnp_ntp)
    except IOError:
        logger.info("NTP sync with %s failed", pnp_ntp)
        logger.debug(ClockSync.error_info)
    # If 'pnpntpserver.<domain>' does not resolve and trustpool bundle
    # is present, Agent attempts NTP sync using 'pnpserver.<domain>'
    if not clock_synced and ca_download_url:
        try:
            clock_synced = ClockSync.set_ntp_server(pnpserver)
        except IOError:
            logger.info("NTP sync with %s failed", pnpserver)
            logger.debug(ClockSync.error_info)
    if not clock_synced:
        logger.warning("Attempting HTTPS DNS Discovery without NTP sync")

    # Try sending HELLO over HTTPS
    if ConnectionManager(https_conn_info).is_valid():
        return https_conn_info

    if not _is_ca_file_present(https_conn_info):
    # HTTP based Discovery
        logger.debug("Trying HTTP discovery through %s", pnpserver)
        http_conn_info = ConnectionInfo(transport=consts.PNP_TRANSTYPE_HTTP,
                                        address=pnpserver,
                                        port=80)
        logger.debug(http_conn_info)
        if ConnectionManager(http_conn_info).is_valid():
            return http_conn_info
    else:
    # seek to remove trustpool upon DNS discovery failure in case the trustpool
    # download has succeeded and the failure has happened in the hello exchange
        uninstall_certificate_bundle('dns_trustpool')
    logger.debug("DNS discovery methods exhausted for %s", domain_name)

