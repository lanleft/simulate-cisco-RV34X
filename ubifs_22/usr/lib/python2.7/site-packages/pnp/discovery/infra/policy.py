################################################################################
# Copyright (c) 2015-17 by Cisco Systems, Inc.
# All rights reserved.
#
# Author: Shaurin Desai <shaurdes@cisco.com>
################################################################################
"""Loads the PnP Discovery Policy.

This module provides access to the PnP Discovery policy. Policy is loaded upon
initialization of a Discovery class instance.

Todo:
    * Move discovery policy from discovery_policy to pnp_config as part of pnp
        config consolidation effort.

"""
from logging import getLogger
from os.path import isfile

import pnp.infra.utils.pnp_constants as consts
from pnp.discovery.infra.errors import DiscoveryAPIError
from pnp.infra.utils.pnp_file_paths import filepaths

# Platform-Dependent imports. If unavailable, pnp will skip discovery mechanisms
# reliant on imported objects.
try:
    from pnp.discovery.mechanisms.platform_discovery import platform_discovery
except DiscoveryAPIError:
    platform_discovery = None
try:
    from pnp.discovery.infra.lease_parser import get_option_strings
except DiscoveryAPIError:
    get_option_strings = None

logger = getLogger(__name__)


class DiscoveryPolicy(object):
    """Provides access to the PnP Discovery policy."""

    @property
    def mechanisms(self):
        """list(tuple): Sequence of (discovery_mechanism func object, parameter)
        tuples. Will be default sequence if policy is malformed/unavailable.
        """
        # Returns list of available discovery mechanisms
        if self._discovery_mechanisms:
            return self._discovery_mechanisms
        else:
            return self._default_mechanisms

    @property
    def retry_time(self):
        """int: Discovery retry wait time upon exhausting discovery mechanisms.
        Will be default retry time (60) if policy is malformed/unavailable.
        """
        if self._retry_time:
            return self._retry_time
        else:
            return self._default_retry_time

    def __init__(self, policy_path=None):
        """Load PnP Discovery policy if available, use default values otherwise.

        Args:
            policy_path (str, optional): Absolute path to discovery policy file.
                Defaults to value found in file paths configuration.

        """
        # mapping discovery mechanisms from policy file to mechanism function
        # object and protocol to run on
        self._valid_mechanisms = {}
        self._default_mechanisms = []
        self._populate_valid_mechanisms()
        # sleep len when all mechanisms are exhausted
        self._default_retry_time = 60
        self._retry_time = 0
        self._discovery_mechanisms = []
        # attempt to load policy
        self._load_policy(policy_path)

    def _load_policy(self, policy_path=None):
        """Loads discovery policy from policy file.

        Modifies: self._discovery_mechanisms, self._retry_time

        Args:
            policy_path (str, optional): Absolute path to discovery policy file.
                Defaults to value found in file paths configuration.
        """
        if policy_path:
            discovery_policy = policy_path
        else:
            try:
                discovery_policy = filepaths['discovery']['policy']
            except KeyError:
                logger.exception("pnp_platform file_paths config is missing "
                                 "path to Discovery policy")
                return
        # empty file path configured
        if not discovery_policy:
            return
        elif not isfile(discovery_policy):
            logger.warning("Invalid path to discovery policy")
            return
        else:
            with open(discovery_policy, 'r') as policy_file:
                for line in policy_file:
                    if not line or line.startswith('#'):
                        continue
                    elif line[0].isalpha():
                        self._discovery_mechanisms = self._load_mechanisms(line)
                    elif line[0].isdigit():
                        self._retry_time = self._load_retry_time(line)


    def _populate_valid_mechanisms(self):
        """Populates set of valid discovery mechanisms, which is determined by
        platform API availability.

        Modifies: self._valid_mechanisms, self._default_mechanisms

        """
        # if Lease Parser API is implemented, allow for DHCP and DNS discovery
        if get_option_strings:
            # import statement is inside function to avoid importing modules
            # when the dependent pnp_platform API is not available
            from pnp.discovery.mechanisms.dhcp_discovery import dhcp_discovery
            from pnp.discovery.mechanisms.dns_discovery import dns_discovery
            self._valid_mechanisms.update({
                'dhcp_ipv4': (dhcp_discovery, consts.PNP_ADDRTYPE_IPV4),
                'dhcp_ipv6': (dhcp_discovery, consts.PNP_ADDRTYPE_IPV6),
                'dns_ipv4': (dns_discovery, consts.PNP_ADDRTYPE_IPV4),
                'dns_ipv6': (dns_discovery, consts.PNP_ADDRTYPE_IPV6)
            })
            # Define default discovery mechanism sequence
            if consts.IPV6_ENABLED:
                self._default_mechanisms = [
                    (dhcp_discovery, consts.PNP_ADDRTYPE_IPV4),
                    (dhcp_discovery, consts.PNP_ADDRTYPE_IPV6),
                    (dns_discovery, consts.PNP_ADDRTYPE_IPV4),
                    (dns_discovery, consts.PNP_ADDRTYPE_IPV6)
                ]
            else:
                self._default_mechanisms = [
                    (dhcp_discovery, consts.PNP_ADDRTYPE_IPV4),
                    (dns_discovery, consts.PNP_ADDRTYPE_IPV4)
                ]
        if consts.CCO_ENABLED:
            # import statement is inside function to avoid circular dependency
            # discovery>cco_discovery>pnp_agent>discovery_manager>discovery
            from pnp.discovery.mechanisms.cco_discovery import cco_discovery
            # PnP Connect requires no pnp_platform API implementation
            self._valid_mechanisms.update({
                'cco_ipv4': (cco_discovery, consts.PNP_ADDRTYPE_IPV4),
                'cco_ipv6': (cco_discovery, consts.PNP_ADDRTYPE_IPV6)
            })
            self._default_mechanisms.append(
                (cco_discovery, consts.PNP_ADDRTYPE_IPV4)
            )
            if consts.IPV6_ENABLED:
                self._default_mechanisms.append(
                    (cco_discovery, consts.PNP_ADDRTYPE_IPV6)
                )
        # if Platform Discovery API is implemented, allow for platform_discovery
        if platform_discovery:
            platform_mechanism = (platform_discovery, 'platform')
            self._valid_mechanisms.update(
                {platform_discovery.__name__: platform_mechanism}
            )
            # Insert platform discovery mechanism before CCO Discovery
            if consts.CCO_ENABLED:
                platform_index = -1
                if consts.IPV6_ENABLED:
                    platform_index = -2
                self._default_mechanisms.insert(platform_index,
                                                platform_mechanism)
            else:
                self._default_mechanisms.append(platform_mechanism)

    def _load_mechanisms(self, mechanisms_string):
        """Parses mechanisms string for valid discovery mechanisms. Returns list
        of validated mechanisms in the same sequence.
        """
        sequence = []
        for mech in mechanisms_string.split(', '):
            mechanism = mech.strip()
            if mechanism in self._valid_mechanisms.keys():
                sequence.append(self._valid_mechanisms[mechanism])
            else:
                error = "Invalid discovery mechanism entered: %s" % mechanism
                logger.error(error)
        mechs = ["%s(%s)" % (mech.__name__, proto) for mech, proto in sequence]
        logger.debug("Discovery mechanism sequence found: %s", ', '.join(mechs))
        return sequence

    def _load_retry_time(self, time_string):
        """Validates entered time string and returns value found. If no valid
         time is found, default_retry time is returned.
         """
        try:
            time = int(time_string.strip())
        except ValueError:
            logger.warning("Discovery retry time must be an integer; using "
                           "default time")
            return self._default_retry_time
        if time < 1:
            logger.warning("Retry time < 1 second disallowed; using default"
                           " time")
            return self._default_retry_time
        logger.debug("Discovery retry time configured: %s secs", time)
        return time

    def __str__(self):
        template = ("Discovery Policy:\nMechanism Sequence: {sequence}\nRetry "
                    "Time: {retry_time}")
        sequence = ["%s (%s)" % (m[0], m[1]) for m in self.mechanisms]
        sequence_str = ", ".join(sequence)
        if self.mechanisms == self._default_mechanisms:
            sequence_str += '  [Default]'
        retry_str = "%s seconds" % self.retry_time
        if self.retry_time == self._default_retry_time:
            retry_str += '  [Default]'
        return template.format(sequence=sequence_str, retry_time=retry_str)


if __name__ == '__main__':
    print DiscoveryPolicy()
