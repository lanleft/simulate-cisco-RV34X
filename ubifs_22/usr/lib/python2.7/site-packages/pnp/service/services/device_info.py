################################################################################
# Copyright (c) 2015-18 by Cisco Systems, Inc.
# All rights reserved.
#
# Author: Shaurin Desai <shaurdes@cisco.com>
################################################################################
"""PnP Service: Device-Info

Device-Info service provides device information to a PnP Server. This service
implementation requires that Device API has been implemented by pnp_platform.
Only profile information is retrieved without dependency on pnp_platform.

"""
import pnp.infra.utils.pnp_constants as consts
from pnp.infra.system.cdp import CDP
from pnp.infra.utils.pnp_utils import (is_valid_ipv4_address,
                                       is_valid_ipv6_address,
                                       load_platform_info, read_pnp_config)
from pnp.service.api.pnp_service import PnPService


class DeviceInfoError(Exception):
    """Device Info Error (inherits from Exception)"""
    pass


class DeviceInfo(PnPService):
    """PnP Service: Device-Info
    """
    _request_type = None
    _platform_info = dict()

    def run(self):
        """Generates the Device-Info Work-Response."""
        self._request_type = self.request['deviceInfo']['@type']
        self._platform_info = load_platform_info()
        result = False
        try:
            result = self._get_device_info()
        except DeviceInfoError as err:
            self.logger.debug(err)
        self.success = int(result)

    def _get_device_info(self):
        """Populates response dictionary with device information depending on
        request type.

        Modifies: self.response

        Returns:
            bool: True on successful device info response generation. False,
                otherwise.

        """
        result = False
        if not self._request_type:
            err_msg = "Device Info request type not found"
            self.logger.error(err_msg)
            self.set_error_info(code='REQ', msg=err_msg)
        elif self._request_type == 'image':
            result = self._get_image_info()
        elif self._request_type == 'hardware':
            result = self._get_hardware_info()
        elif self._request_type == 'filesystem':
            result = self._get_file_system_list()
        elif self._request_type == 'udi':
            result = self._get_udi()
        elif self._request_type == 'profile':
            result = self._get_profile_info()
        elif self._request_type == 'all':
            result = (self._get_image_info() and self._get_hardware_info() and
                      self._get_file_system_list() and self._get_udi() and
                      self._get_profile_info())
        else:
            err_msg = "Device Info request type unsupported"
            self.logger.error(err_msg)
            self.set_error_info(code='REQ', msg=err_msg)
        return result

    def _get_image_info(self):
        """Gets the image information and formats it into the expected
        work-response format.

        Modifies: self.response['imageInfo'] will contain the found info.

        Returns:
             bool: True, upon successful imageInfo generation. False, otherwise.

        Raises: DeviceInfoError

        """
        image_info_keys = ['versionString', 'returnToRomReason', 'bootVariable',
                           'bootLdrVariable', 'configVariable', 'configReg',
                           'configRegNext', 'imageFile', 'imageHash']
        self.response['imageInfo'] = dict.fromkeys(image_info_keys, '')
        try:
            self._populate_with_platform_info('imageInfo')
        except Exception as err:
            err_msg = "Failed to retrieve image info"
            self.logger.error(err_msg)
            self.set_error_info(code='DEVICE_IMAGE_INFO_RETRIEVE', msg=err_msg)
            # Clear incomplete image information from response
            self.response.pop('imageInfo')
            raise DeviceInfoError(err)
        return True

    def _get_hardware_info(self):
        """Gets the hardware information and formats it into the expected
        work-response format.

        Modifies: self.response['hardwareInfo'] will contain the found info.

        Returns:
            bool: True, upon successful hardwareInfo generation. False,
                otherwise.

        Raises: DeviceInfoError

        """
        hardware_info_keys = ['hostname', 'vendor', 'platformName',
                              'processorType', 'hwRevision', 'mainMemSize',
                              'ioMemSize', 'boardId', 'boardReworkId',
                              'processorRev', 'midplaneVersion', 'location',
                              'deviceType', 'deviceModel']
        self.response['hardwareInfo'] = dict.fromkeys(hardware_info_keys, '')
        try:
            self._populate_with_platform_info('hardwareInfo')
            # Populate location from get_tag of CDP service
            location_tag = ''
            location_tag_cdp = CDP.get_cdp_app_tag()
            if location_tag_cdp:
                location_tag = location_tag_cdp
            self.response['hardwareInfo']['location'] = location_tag
        except Exception as err:
            err_msg = "Failed to retrieve hardware info"
            self.logger.error(err_msg)
            self.set_error_info(code='DEVICE_HARDWARE_INFO_RETRIEVE',
                                msg=err_msg)
            # Clear incomplete hardware information from response
            self.response.pop('hardwareInfo')
            raise DeviceInfoError(err)
        return True

    def _get_file_system_list(self):
        """Gets the file system information and formats it into the expected
        work-response format.

        Modifies: self.response['fileSystemList'] will contain a list of
                  dictionaries, each representing a fileSystem element.

        Returns:
            bool: True, upon successful fileSystemList generation. False,
                otherwise.

        Raises: DeviceInfoError

        """
        try:
            fs_list = []
            for fs in self._platform_info['fileSystemList']:
                fs_list.append(fs['fileSystem'])
        except Exception as err:
            err_msg = "Failed to retrieve filesystem info"
            self.logger.error(err_msg)
            self.set_error_info(code='DEVICE_FILESYSTEM_INFO_RETRIEVE',
                                msg=err_msg)
            raise DeviceInfoError(err)
        self.response['fileSystemList'] = {}
        self.response['fileSystemList']['fileSystem'] = fs_list
        return True

    def _get_udi(self):
        """Gets the UDI information and formats it into the expected
        work-response format.

        Modifies: self.response['udi'] will contain the found UDI info.

        Returns:
            bool: True, upon successful UDI generation. False, otherwise.

        Raises: DeviceInfoError

        """
        self.response['udi'] = {}
        self.response['udi']['primary-chassis'] = ''
        try:
            self._populate_with_platform_info('udi')
        except Exception as err:
            err_msg = "Failed to retrieve UDI info"
            self.logger.error(err_msg)
            self.set_error_info(code='INTERNAL', msg=err_msg)
            # Clear incomplete UDI information from response
            self.response.pop('udi')
            raise DeviceInfoError(err)
        return True

    def _get_profile_info(self):
        """Gets the PnP Profile information and formats it into the expected
        work-response format.

        Modifies: self.response['profileInfo'] will contain a list of
                  dictionaries, each representing a profile element.

        Returns:
            bool: True, upon successful profileInfo generation. False,
                otherwise.

        """
        profile = read_pnp_config()
        if not profile:
            err_msg = "Failed to retrieve profile info"
            self.logger.error(err_msg)
            self.set_error_info(code='DEVICE_PROFILE_INFO_RETRIEVE',
                                msg=err_msg)
            return False
        self.response['profileInfo'] = []
        # Generate profile information
        profile_info = dict()
        profile_info['@profile-name'] = 'Profile ' + consts.PNP_PROFILE
        profile_info['@discovery-created'] = True
        created_by = profile.get('created_by')
        if created_by == 'user':
            profile_info['@discovery-created'] = False
            profile_info['@created-by'] = 'user'
        elif created_by == 'dhcp_discovery':
            profile_info['@created-by'] = 'PnP-DHCP'
        elif created_by == 'dns_discovery':
            profile_info['@created-by'] = 'PnP-DNS'
        elif created_by == 'cco_discovery':
            profile_info['@created-by'] = 'PnP-CCO'
        else:
            self.logger.error("Unable to determine profile 'created-by'")
            self.set_error_info(code='DEVICE_PROFILE_INFO_RETRIEVE',
                                msg="Unable to determine profile source")
            # Clear incomplete profile information from response
            self.response.pop('profileInfo')
            return False
        # Generate primary-server information
        profile_info['primary-server'] = {}
        protocol = profile.get('transport')
        profile_info['primary-server']['protocol'] = protocol
        profile_info['primary-server']['server-address'] = {}
        addr = profile.get('address')
        # Determine if address is ipv4, ipv6 or host
        if is_valid_ipv4_address(addr):
            addr_type = consts.PNP_ADDRTYPE_IPV4
        elif is_valid_ipv6_address(addr):
            addr_type = consts.PNP_ADDRTYPE_IPV6
        else:
            addr_type = consts.PNP_ADDRTYPE_HOST
        profile_info['primary-server']['server-address'][addr_type] = addr
        port = profile.get('port')
        if port:
            profile_info['primary-server']['server-address']['port'] = port
        self.response['profileInfo'].append({'profile': profile_info})
        return True

    def _populate_with_platform_info(self, response_dict_key):
        """Updates response dict with data from platform info file.

        Args:
            response_dict_key (str): response dict key to populate

        Modifies: self.response

        """
        for key, val in self._platform_info[response_dict_key].iteritems():
            if key in self.response[response_dict_key]:
                self.response[response_dict_key][key] = val
