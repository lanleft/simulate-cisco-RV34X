################################################################################
# Copyright (c) 2017 by Cisco Systems, Inc.
# All rights reserved.
#
# Author: Andrew Au <aau@cisco.com>
################################################################################
"""PnP Service: Script

This service will retrieve a provided Python/TCL script from the given source,
run it and collect its execution output to send back to the Server.

"""
import os
import re
from logging import getLogger
from xml.sax.saxutils import escape

from pnp.infra.system.script_exec import (parse_script_preamble,
                                          script_download, script_execute,
                                          script_get_results)
from pnp.infra.utils.file_utils import write_data_to_file
from pnp.infra.utils.pnp_file_paths import filepaths
from pnp.infra.utils.pnp_utils import compose_url, parse_url, profile_exists
from pnp.service.api.pnp_service import PnPService

logger = getLogger(__name__)


class Script(PnPService):
    """Script service to retrieve a provided Python/TCL script from the
    given source, run it and collect its execution output to send back to
    the Server.
    """
    results = dict.fromkeys(list(('exec_result', 'rfile', 'exec_log',
                                  'details')))
    stype = None
    mwait = None
    source = None
    src_arg = None
    cmd_args = None
    script_local = None

    def run(self):
        """Generates the script Work-Response"""
        src_dict = {'location': self.process_script_loc,
                    'uri': self.process_script_uri,
                    'inline': self.process_script_inline}
        script_svc = self.request['script']
        if not self.parse_req_input(script_svc):
            # self.compose_resp() is done inside parse_req_input()
            return

        key = self.source.keys()[0]
        if key not in src_dict:
            self.exec_error_log = "Script source given invalid"
            self.compose_resp(False, "REQ")
            return
        self.src_arg = self.source.get(key)

        # Call the exec function in src_dict{} according to the source type
        rc = src_dict[key]()
        if rc:
            if self.results['exec_result'] == -9:
                # exec_result of -9 means a timeout kill of the script
                # execution; set the Response msg accordingly
                self.exec_error_log = "Execution of script timed out"
            self.compose_resp(False, rc)
        else:
            self.compose_resp(True, None)

    def parse_req_input(self, script_svc):
        """This method parses the Request input, validate them & set them
        in place in this object.
        """
        stype = script_svc.get('@stype')
        if stype and stype not in ['python', 'tcl']:
            # Let the case of having stype==None pass for the moment so to
            # to wait for preamble check
            self.exec_error_log = ("Script type %s unsupported" %stype)
            self.compose_resp(False, "UNEXPECTED_FILE_TYPE")
            return False

        self.stype = stype
        self.results['details'] = script_svc.get('@details', 'all')
        self.results['rfile'] = script_svc.get('@resultFile')
        self.mwait = script_svc.get('@maxWait')
        self.cmd_args = script_svc.get('arguments')

        # input validations
        scopy = script_svc.get('copy')
        if not scopy:
            self.exec_error_log = ("Script copy element mandatory "
                                   "but missing")
            self.compose_resp(False, "REQ")
            return False
        self.source = scopy.get('source')
        if not self.source or len(self.source) != 1:
            self.exec_error_log = ("# of Script source element given not "
                                   "equal 1")
            self.compose_resp(False, "REQ")
            return False
        self.mwait = extract_maxwait(self.mwait)
        if not self.mwait:
            self.exec_error_log = "Script maxWait attribute given invalid"
            self.compose_resp(False, "REQ")
            return False
        if self.results['details'] not in ['brief', 'errors', 'all']:
            self.exec_error_log = "Script details attribute given invalid"
            self.compose_resp(False, "REQ")
            return False

        msg_template = ("Script Service Request rcvd; type: %s, "
                        "script source: %s, details: %s, result-file: %s, "
                        "max-wait: %s, arguments: %s")
        self.logger.info(msg_template, self.stype, self.source,
                         self.results['details'], self.results['rfile'],
                         self.mwait, self.cmd_args)
        return True

    def compose_resp(self, status, err_code):
        """This method composes the Service Response msg to send back to
        the Server

        Input: status - True means successful completion of script execution
                        False, otherwise
               err_code - error code generated during the script execution

        Output: a Service Response composed in self.response
        """
        if self.results['rfile']:
            # Retrieve the result data saved in the given result data file
            rdata = script_get_results(self.results['rfile'])
            # escape '<' and '>' to not confuse the Response XML
            if rdata:
                self.response['resultData'] = escape(rdata)
        if self.results['exec_log']:
            # Filter service log according to the details level given
            slog = filter_service_log(status, self.results['exec_log'],
                                      self.results['details'])
            if slog:
                # escape '<' and '>' to not confuse the Response XML
                slog = escape(slog)
                self.exec_output_log = slog

        if status:
            self.success = True
            self.logger.info("Script Service successfully "
                             "executed & Response composed")
            return

        # Failure, return success 0 with error code
        self.success = False
        msg = self.exec_error_log
        if not msg:
            # set msg to '' as set_error_info can't take msg=None
            msg = ''
        else:
            # escape '<' and '>' to not confuse the Response XML
            msg = escape(msg)
        self.set_error_info(code=err_code, msg=msg)
        self.logger.error(msg)

    def process_script_loc(self):
        """This method processes a script provided at a given location
        which is an absolute path. It passes this location's specified
        download scheme, address and path, if any, to the PD code to
        execute the downloading.
        """
        self.logger.debug("processing script at given location %s",
                          self.src_arg)
        scheme, netloc, path = parse_url(self.src_arg)
        self.logger.debug("download scheme: %s, network-loc: %s, "
                          "path: %s", scheme, netloc, path)

        self.logger.debug("location to download script: " + self.src_arg)
        script_local_cpy = set_script_local_path()
        rc = script_download(self.src_arg, script_local_cpy)
        if rc:
            self.results['exec_result'] = None
            self.exec_error_log = "Failed to download script"
            return rc

        # If script type isn't known yet, parse the script file's preamble
        # for it to set it in place
        if not self.stype:
            preamble = parse_script_preamble(script_local_cpy)
            if not preamble:
                self.exec_error_log = "Unknown script type to execute"
                return "UNEXPECTED_FILE_TYPE"
            self.stype = preamble

        # Execute script now
        self.results['exec_result'], errmsg, self.results['exec_log'] = \
            script_execute(self.stype, script_local_cpy, self.mwait,
                           self.cmd_args)
        self.logger.debug("script's return value: %s; error: %s; output: %s",
                          self.results['exec_result'], errmsg,
                          self.results['exec_log'])
        if self.results['exec_result']:
            self.exec_error_log = errmsg
            return "EXEC_FAILED"
        return None

    def process_script_uri(self):
        """This method processes a script provided at a given URI, which
        is a relative path, before which is used for downloading, the
        PnP Service's known protocol, addr and port from the profile will
        be retrieved and attached in front of this given URL.
        """
        self.logger.debug("processing script at given URI %s", self.src_arg)
        scheme, netloc, path = parse_url(self.src_arg)
        self.logger.debug("download scheme: %s, network-loc: %s, "
                          "path: %s", scheme, netloc, path)
        if not path:
            self.exec_error_log = "URI element missing file path"
            return "REQ"

        config = profile_exists()
        if scheme:
            protocol = scheme
        else:
            protocol = config.get('transport', 'http')
        address = config.get('address')
        port = config.get('port', '80')
        # Validate that this given URI is a relative path that doesn't
        # conflict with the known PnP Server addr:port
        if netloc and (netloc != address + ':' + port):
            self.exec_error_log = ("URI element with conflicting network "
                                   "location")
            return "REQ"

        path = compose_url(protocol, address, port) + path
        self.logger.debug("absolute path for URI to download script: "+ path)
        script_local_cpy = set_script_local_path()
        rc = script_download(path, script_local_cpy)
        if rc:
            self.results['exec_result'] = None
            self.exec_error_log = "Failed to download script"
            return rc

        # If script type isn't known yet, parse the script file's preamble
        # for it to set it in place
        if not self.stype:
            preamble = parse_script_preamble(script_local_cpy)
            if not preamble:
                logstr = "Unknown script type to execute"
                self.exec_error_log = logstr
                return "UNEXPECTED_FILE_TYPE"
            self.stype = preamble

        # Execute script now
        self.results['exec_result'], errmsg, self.results['exec_log'] = \
            script_execute(self.stype, script_local_cpy, self.mwait,
                           self.cmd_args)
        self.logger.debug("script's return value: %s; error: %s; output: %s",
                          self.results['exec_result'], errmsg,
                          self.results['exec_log'])
        if self.results['exec_result']:
            self.exec_error_log = errmsg
            return "EXEC_FAILED"
        return None

    def process_script_inline(self):
        """This method processes an inline command
        """
        self.logger.debug("processing inline script: %s", self.src_arg)
        if not self.stype:
            # Return error upno unspecified script type, since for inline
            # there's no script preamble to tell
            self.exec_error_log = "Unknown inline script type to execute"
            return "UNEXPECTED_FILE_TYPE"

        script_local_cpy = set_script_local_path()
        try:
            try:
                if os.path.isfile(script_local_cpy):
                    os.remove(script_local_cpy)
            except OSError:
                self.exec_error_log = ("Failed to remove old script archive "
                                       "locally")
                return "INTERNAL"

            # save the inline script into a backup file
            write_data_to_file(self.src_arg, script_local_cpy)
        except (IOError, OSError) as exe:
            self.logger.error("Failed to write inline script into temp file; "
                              "exception: %s", script_local_cpy, repr(exe))
            self.exec_error_log = "Failed to write script into local file"
            return "INTERNAL"

        # Execute script now
        self.results['exec_result'], errmsg, self.results['exec_log'] = \
            script_execute(self.stype, script_local_cpy, self.mwait,
                           self.cmd_args)
        self.logger.debug("script's return value: %s; error: %s; output: %s",
                          self.results['exec_result'], errmsg,
                          self.results['exec_log'])
        if self.results['exec_result']:
            self.exec_error_log = errmsg
            return "EXEC_FAILED"
        return None


def extract_maxwait(time_input):
    """The maxWait attribute in the Script Service Request comes in the
    format "PTxxS". This function seeks to read & return the time value in
    between the 'PT' prefix and the 'S' postfix.

    Args:
        time_input (str): maxWait time in the format of "PTxS" where x
            is the time value

    Returns:
        (str): the extracted value, or 3600 which is the default, if
            no maxWait is present; otherwise, None upon error, e.g.
            wrong format
    """
    default_max_wait = '3600'
    if not time_input:
        return default_max_wait
    criteria = re.compile(r'^PT\d+S$')
    if not criteria.match(time_input):
        # return the default max wait in seconds
        return None
    # extract & return the time value in between the 'PT' prefix and the 'S'
    # postfix.
    result = time_input[2:-1]
    if result:
        return result
    else:
        return None


def filter_service_log(status, log_str, details):
    """This function applies the given log level to filter out the wanted
    contents of the given log.

    Args:
        status (boolean): True means successful completion of script
            execution; False otherwise
        log_str (str): the service log string to be filtered
        details (str): level of details to filter out

    Returns:
        (str) the filtered out contents of the service log
    """
    logger.debug("Filtering service log at level: " + details)
    if details == "all":
        return log_str
    if not status and details == "errors":
        return log_str
    # the "brief" case falls here of course
    return None


def set_script_local_path():
    """This function seeks to find a tmpfs directory to save the script;
    try /run & /tmp. If both are absent, try the log dir used by PnP.

    Returns:
        (str): the absolute path to the file where the script is
            archived
    """
    dirlist = ['/run', '/tmp']
    for mydir in dirlist:
        if os.path.isdir(mydir):
            return os.path.join(mydir, "svc_script")
    # It's unusual even if filepaths['log']['log_dir'] is absent or unusable.
    # For simplicity, let it go and be failed there upon the attempt for use.
    return os.path.join(filepaths['log']['log_dir'], "svc_script")
