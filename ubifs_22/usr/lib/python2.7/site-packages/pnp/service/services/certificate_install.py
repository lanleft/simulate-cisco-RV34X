################################################################################
# Copyright (c) 2015-17 by Cisco Systems, Inc.
# All rights reserved.
#
# Author: Shaurin Desai <shaurdes@cisco.com>
################################################################################
"""PnP Service: Certificate-Install

This implementation does not fully support the Certificate Install schema. The
unhandled schema elements include "reconnect" for setting detailed PnP Server
reconnection parameters.

Todo:
    * check HTTPS HELLO before switching to HTTPS profile
    * support "reconnect" schema element
    * improve error info reporting
    * refactor CCO-Cert-Install to check for cco-timer instead of an existing
        profile

"""
import hashlib
import os
import urllib2
from ssl import CertificateError

import pnp.infra.system.certificate as server_auth
import pnp.infra.utils.pnp_utils as utils
import pnp.infra.utils.timer as timer
from pnp.infra.errors import SEVERITY_ERROR
from pnp.infra.network.security import load_csdl_ssl_context
from pnp.infra.network.vrf import VRF
from pnp.infra.system.certificate import get_embedded_certificate
from pnp.infra.system.clock_sync import ClockSync
from pnp.infra.utils.pnp_constants import (CCO_CERT, CCO_DISCOVERY_TIMER,
                                           PNP_ADDRTYPE_HOST, PNP_ADDRTYPE_IPV4,
                                           PNP_ADDRTYPE_IPV6)
from pnp.service.api.pnp_service import PnPService


class CertificateInstallError(Exception):
    """Certificate Install Error (inherits from Exception)"""
    pass


class CertificateInstall(PnPService):
    """PnP Service: Certificate-Install"""

    _request_type = ''  # install or uninstall
    _cert_type = ''  # trustpoint (.pem) or trustpool (.p7b)
    _cert_label = ''  # only used when _cert_type is trustpoint
    _cert_source = None  # tuple ('uri' or 'location', <uri> or <location>)
    _set_clock = None  # tuple ('ntp' or 'clock', <ntp> or <clock>)
    _cert_checksum = ''
    _download_path = ''

    def run(self):
        """Generates the Certificate-Install Work-Response."""
        result = False
        if self._validate_request():
            result = self.__getattribute__(self._request_type)()
            if result and self._set_clock:
                result = self._sync_system_clock()
        if result:
            self.success = True
        else:
            self.success = False
            self.set_error_info(SEVERITY_ERROR, 'REQ',
                                "Error install certificate")

    def _validate_request(self):
        """Sets the work-request and determines the request type.

        Modifies: _request_type, _cert_type, _cert_label, _cert_source

        Returns:
            bool: True, if request successfully set. False, otherwise.

        """
        try:
            cert_elem = self.request['certificateInstall']['cert']
            # Determine if install or uninstall is being requested
            if cert_elem.get('install'):
                self._request_type = 'install'
            else:
                self._request_type = 'uninstall'
            # Determine the type of certificate being accessed
            if cert_elem[self._request_type].get('trustpoint'):
                self._cert_type = 'trustpoint'
            else:
                self._cert_type = 'trustpool'
            if self._cert_type == 'trustpoint':
                self._cert_label = (cert_elem[self._request_type]
                                    ['trustpoint'].get('label', 'pem'))
            # Get certificate download source
            if self._request_type == 'install':
                source = cert_elem['install'][self._cert_type]['copy']['source']
                if source.get('uri'):
                    self._cert_source = ('uri', source.get('uri'))
                else:
                    self._cert_source = ('location', source.get('location'))
                # Fill checksum
                if 'checksum' in source:
                    self._cert_checksum = source.get('checksum')

            # Determine is clock sync if requested
            if cert_elem.get('set'):
                if cert_elem['set'].get('ntp'):
                    self._set_clock = ('ntp', cert_elem['set']['ntp'])
                else:
                    self._set_clock = ('clock', cert_elem['set']['clock'])
        except KeyError:
            self.logger.exception("Malformed request from PnP Server")
            return False
        return True

    def install(self):
        """Downloads and installs the certificate using the data found in the
        work request

        Returns:
            bool: True, if certificate is installed successfully. False,
                otherwise.

        """
        # Determine the certificate file download source address
        if self._cert_source[0] == 'location':
            source = self._cert_source[1]
        else:
            # Construct source download address using server address and
            # location provided in work request
            config = utils.profile_exists()
            address = config.get('address')
            port = config.get('port', '80')
            transport = config.get('transport', 'http')
            server_address = utils.compose_url(transport, address, port)
            if not server_address:
                self.logger.error('Failed to compose download URL')
                return False
            source = server_address + self._cert_source[1]
        # Construct file path to download file to
        cert_dir = server_auth.get_certificates_location(self._cert_type)
        download_path = os.path.join(cert_dir, source.split('/')[-1])
        # Download the certificate file
        try:
            # Create SSL Context to download file (if needed)
            if 'https://' in source:
                config = utils.profile_exists()
                cafile = None
                if config:
                    cafile = config.get('cafile')
                elif timer.timer_exists(CCO_DISCOVERY_TIMER):
                    # Here we are during CCO Discovery
                    # W/o profile config yet, try w/ embedded root cert
                    self.logger.debug('cert install during CCO Discovery')
                    cafile = get_embedded_certificate(CCO_CERT)
                    if not cafile:
                        self.logger.error('Unable to access HTTPS URL without '
                                          'embedded root certificate')
                        return False
                else:
                    self.logger.error('Unable to access HTTPS URL without '
                                      'certificate')
                    return False
                ctx = load_csdl_ssl_context(cafile)
            else:
                ctx = None
            # Send URL request
            VRF.set_vrf()
            response = urllib2.urlopen(url=source, context=ctx)
            # Validate file download
            if response.getcode() is not 200:
                self.logger.error('Failed to download certificate from URL')
                self.logger.debug('HTTP Response Code: %d', response.getcode())
                return False
            # Store certificate file data in file system
            with open(download_path, 'w') as cert_file:
                cert_file.write(response.read())
        except (IOError, CertificateError):
            self.logger.exception("Failed to download certificate")
            return False
        # Validate the checksum before install
        try:
            self._validate_checksum()
        except CertificateInstallError:
            self.logger.exception("Certificate Checksum mismatch")
            return False
        # Install the downloaded certificate file
        if self._cert_type == 'trustpoint':
            cert_path = server_auth.install_certificate(download_path,
                                                        self._cert_label)
        else:
            cert_path = server_auth.install_certificate_bundle(download_path)
        # clean up downloaded file
        if os.path.isfile(download_path):
            os.remove(download_path)
        # Verify installation
        if not cert_path:
            return False
        # Update PnP Profile, if necessary. Assume execution is in CCO Discovery
        # context if no profile exists in pnp_config.
        if utils.profile_exists():
            # if the optional reconnect element is not found, do not update the
            # PnP Profile to use the installed certificate
            if 'reconnect' not in self.request['certificateInstall']:
                return True
            server_info = (self.request['certificateInstall']['reconnect']
                           ['primary-server'])
            new_config = {
                'transport': server_info.get('protocol', 'https'),
                'port': str(server_info['server-address'].get('port', '443')),
                'cafile': cert_path
            }
            if server_info['server-address'].get(PNP_ADDRTYPE_IPV4):
                new_ip = server_info['server-address'].get(PNP_ADDRTYPE_IPV4)
                new_config.update({'address': new_ip})
            elif server_info['server-address'].get(PNP_ADDRTYPE_IPV6):
                new_ip = server_info['server-address'].get(PNP_ADDRTYPE_IPV6)
                new_config.update({'address': new_ip})
            elif server_info['server-address'].get(PNP_ADDRTYPE_HOST):
                new_ip = server_info['server-address'].get(PNP_ADDRTYPE_HOST)
                new_config.update({'address': new_ip})
            utils.update_pnp_config(new_config)
        return True

    def _validate_checksum(self):
        """Raises Certificate Installation Error upon checksum mismatch
           Validation is done with md5 hash.
           Todo: Add vaidation/encryption method in response from
                 server and use it decrypt & validate
                 Error code to be changed after checking with IOS agent
        """
        if not self._cert_checksum:
            return
        with open(self._download_path, 'rb') as cert_file:
            actual_checksum = hashlib.md5(cert_file.read()).hexdigest()
        if actual_checksum != self._cert_checksum:
            self.set_error_info(code='SIGNATURE_VERIFY_FAILED',
                                msg="Certificate Checksum mismatch!")
            raise CertificateInstallError("Bad Checksum for certificate %s"
                                          % actual_checksum)

    def uninstall(self):
        """Uninstalls the certificate specified in the work request

        Returns:
            bool: True, if certificate is uninstalled successfully. False,
                otherwise.

        """
        if self._cert_type == 'trustpool':
            result = server_auth.uninstall_certificate_bundles()
        else:
            result = server_auth.uninstall_certificate(self._cert_label)
        return result

    def _sync_system_clock(self):
        """Calls clock sync API with request data.

        Returns:
            bool: True, if clock sync is successful. False, otherwise.

        """
        set_elem = self.request['certificateInstall']['cert']['set']
        if self._set_clock[0] == 'ntp':
            try:
                ntp_server_addr = set_elem['ntp']['ip-address']
                return ClockSync.set_ntp_server(ntp_server_addr)
            except KeyError:
                self.logger.exception("<ip-address> not found in <set><ntp>")
            except IOError:
                self.logger.exception("Failed to contact NTP Server")
                self.logger.debug(ClockSync.error_info)
            return False
        else:
            clock_elem = set_elem['clock']
            try:
                clock_time = {
                    'year': int(clock_elem['year']),
                    'month': clock_elem['month'],
                    'day': int(clock_elem['day']),
                    'hour': int(clock_elem['hour']),
                    'minute': int(clock_elem['min']),
                    'second': int(clock_elem['sec'])
                }
            except KeyError:
                self.logger.exception("expected more <set><clock> child "
                                      "elements")
                return False
            return ClockSync.set_system_clock(**clock_time)
