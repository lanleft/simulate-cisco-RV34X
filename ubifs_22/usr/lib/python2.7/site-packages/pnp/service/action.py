################################################################################
# Copyright (c) 2015-17 by Cisco Systems, Inc.
# All rights reserved.
#
# Author: Shaurin Desai <shaurdes@cisco.com>
################################################################################
"""PnP Service Action

The ServiceAction class provides an interface for PnP Services to execute a
routine post-PnP Handshake. PnP Services that require an action to execute after
service completion must store this action behavior in a ServiceAction instance.
These service actions are called through a blocking call and can only be called
once.

"""
from logging import getLogger

from pnp.service.errors import ServiceActionError


class ServiceAction(object):
    """ServiceAction

    An instance contains the action to perform upon PnP Handshake completion.
    """

    _action_function = None
    _action_name = 'NOOP'  # default ServiceAction object will perform a no-op
    _action_args = tuple()
    _action_kwargs = dict()
    _action_result = None
    _has_run = False

    logger = getLogger('pnp.service.ServiceAction')

    def __init__(self, action_func=None, action_name=_action_name,
                 *action_args, **action_kwargs):
        """Initializes ServiceAction class to execute provided action_func with
        provided action_args and action_kwargs parameters when ServiceAction
        instance is called.

        Args:
            action_func (obj): This function (or other callable object) will be
                called upon completion of the PnP Handshake
            action_name (str): Name of the action to perform (for logging
                purposes).
            *action_args: Variable length argument list for action_func.
            **action_kwargs: Arbitrary keyword arguments for action_func.

        Raises:
            TypeError: If non-callable object provided as action_func, or if the
                provided action_name is not a string.
            ValueError: If the provided action_name is an empty string

        """
        # Validate input: action_func
        if not action_func:
            self._action_function = lambda *args, **kwargs: None
        elif not callable(action_func):
            raise TypeError("'action_func' requires a callable object")
        else:
            self._action_function = action_func
        # Validate input: action_name
        if isinstance(action_name, basestring):
            if len(action_name.strip()) == 0:
                raise ValueError("'action_name' cannot be an empty")
            self._action_name = action_name
        else:
            raise TypeError("'action_name' requires a string")
        # Store arguments and/or keyword-arguments to provide to action_func
        if action_args:
            self._action_args = action_args
        if action_kwargs:
            self._action_kwargs = action_kwargs

    def __call__(self):
        if self._has_run:
            raise RuntimeError("Cannot call ServiceAction object (%s) multiple "
                               "times", self._action_name)
        try:
            self._action_result = self._action_function(*self._action_args,
                                                        **self._action_kwargs)
        except Exception as err:
            raise ServiceActionError(err)
        self._has_run = True

    @property
    def result(self):
        """obj: Return value of the executed service action.

        Raises:
            UnboundLocalError: If service action has not yet been called.
        """
        if not self._has_run:
            raise UnboundLocalError("ServiceAction object (%s) has not been "
                                    "called; no result has been generated" %
                                    self._action_name)
        return self._action_result
