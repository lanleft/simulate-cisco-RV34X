################################################################################
# Copyright (c) 2015-17 by Cisco Systems, Inc.
# All rights reserved.
#
# Author: Tai Pham <taipham@cisco.com>
################################################################################
"""PnP Agent

Main entry point for PnP agent, which will handle:
    - Parse PnP connection info
    - Send and receive work requests and responses

Todo:
    * Refactor to remove global 'data' object
    * Refactor to remove global 'index' counter

"""
import random
import sys
import time
import uuid
import xml.etree.ElementTree as ElementTree
from getpass import getuser
from json import dumps as json_dumps
from logging import getLogger
from os import getpgid, getpid, setsid

import pnp.discovery.infra.discovery_manager
import pnp.infra.utils.pnp_constants as consts
import pnp.infra.utils.pnp_logging as pnp_logging
import pnp.infra.utils.pnp_utils as utils
import pnp.infra.utils.timer as timer
from pnp.infra.errors import PnPProfileError
from pnp.infra.faults import FaultInfo, pnp_fault_code, pnp_fault_string
from pnp.infra.profile.profile import Profile
from pnp.infra.profile.profile_manager import ProfileManager
from pnp.infra.system.sudi import SUDI
from pnp.infra.system.user_auth import UserAuth
from pnp.infra.xml.xmlgenerator import (gen_work_request, gen_work_response,
                                        gen_fault_response)
from pnp.infra.xml.xmlparser import XMLParser
from pnp.service.action import ServiceAction
from pnp.service.errors import ServiceActionError
from pnp.service.handler import list_services, load_service

# PnP default starting index value for correlator
index = 0

# dictionary containing data used to populate PnP XML payloads
data = {
    'correlator': '',
    'udi': ''
}

# initiate logging (important when importing this module instead of directly
# running it as __main__)
if not pnp_logging.logging_initiated:
    pnp_logging.initiate_logging()
logger = getLogger(__name__)


def create_work_info_request(profile):
    """Generates Work-Info Work-Request XML payload.

    Args:
        profile (Profile): PnP Profile that will handle Work-Request

    Returns
        str: Work-Info Work-Request XML string populated with profile's data.

    """
    global data  # pylint: disable=global-variable-not-assigned
    data['correlator'] = profile.correlator
    data['auth'] = profile.is_auth_required()
    data['sid'] = profile.session_id
    # Get SUDI if not already loaded into data dictionary
    if not data.get('sudi'):
        sudi = SUDI.sudi()
        if sudi:
            data['sudi'] = sudi
    # Get hostname from platform, must be generated for each work-info request
    platform_info = utils.load_platform_info()
    hostname = platform_info['hardwareInfo'].get('hostname')
    if hostname:
        data['hostname'] = hostname
    work_request_xml = gen_work_request(**data)
    logger.debug("*** Client Work Request ***:")
    logger.debug(work_request_xml)
    return work_request_xml


def create_work_response(request, server_response, profile, fault_info=None):
    """Creates Work-Response for specified request.

    Args:
        request (str): Name of PnP Service requested by PnP Server
        server_response (str): XML string containing Work-Request from Server
        profile (Profile): PnP Profile that will handle request
        fault_info (FaultInfo, optional): This class object contains info
            about any fault generated:

    Returns:
        tuple(ServiceAction, str): tuple containing Service Action and generated
            Work-Response XML string

    """
    fault_code = fault_string = fault_details = None
    logger.debug("*** Receive Server Request ***: type %s", request)
    # Convert XML request to JSON string and provide JSON request to service
    root = ElementTree.XML(server_response)
    XMLParser.remove_namespace(root, request)
    req_dict = XMLParser.etree_to_dict(root)
    req_obscured = utils.obscure_password_in_msg(str(req_dict))
    logger.debug(req_obscured)
    if fault_info:
        # Pass the fault info to the XML generator to generate a Fault Resp
        fault_code = fault_info.code
        fault_string = fault_info.string
        fault_details = fault_info.details
        work_response = gen_fault_response(fault_info, **data)
        logger.info("Generating a fault response with code: %s, "
                    "string: %s, details: %s", fault_code, fault_string,
                    fault_details)
        logger.debug("*** Client Work Response ***:")
        logger.debug(work_response)
        return ServiceAction(), work_response
    request_payload = json_dumps(req_dict['{urn:cisco:pnp}pnp']['request'])
    service = None
    try:
        service = load_service(request.replace('-', '_'), profile)
    except TypeError:
        fault_code = pnp_fault_code['PNP_RECEIVER_FAULT']
        fault_string = pnp_fault_string['PNP_FAULT_STR_INTERNAL']
        fault_details = ("Failed to load requested service: %s; "
                         "exception resulted", request)
    if not service:
        fault_code = pnp_fault_code['PNP_SENDER_FAULT']
        fault_string = pnp_fault_string['PNP_FAULT_STR_OPERATION_FAILED']
        fault_details = "Failed to load requested service: " + request
        fault_info = FaultInfo(fault_code, fault_string, fault_details)
    if fault_code:
        work_response = gen_fault_response(fault_info, **data)
        logger.info("Generating a fault response with code: %s, "
                    "string: %s, details: %s", fault_code, fault_string,
                    fault_details)
        logger.debug("*** Client Work Response ***:")
        logger.debug(work_response)
        return ServiceAction(), work_response
    service.request = request_payload
    if service.request is None:
        return service.action, gen_work_response(service, **data)
    try:
        service.run()
    except Exception:  # pylint: disable=broad-except
        logger.exception("Encountered unhandled error when running service")
        return service.action, gen_work_response(service, **data)
    work_response = gen_work_response(service, **data)
    logger.debug("*** Client Work Response ***:")
    logger.debug(work_response)
    return service.action, work_response


def authenticate_work_request(attrs):
    """Authenticate the user in the server work-request.

    Args:
        attrs (dict): Attributes found in root element of work-request XML.

    Returns:
        bool: True if Work-Request was successfully authenticated, False upon
            failure to authenticate Work-Request

    """
    if not all(attr in attrs for attr in ('usr', 'pwd')):
        return False
    if UserAuth.authenticate_user(attrs['usr'], attrs['pwd']):
        global data  # pylint: disable=global-variable-not-assigned
        data['usr'] = attrs['usr']
        data['pwd'] = attrs['pwd']
        return True
    return False


def process_work_request(auth_required, server_work_request):
    """Parse work request from the server

    Args:
        auth_required (bool): Determines if User Auth is required.
        server_work_request (str): Work-Request XML string from PnP Server

    Returns:
        tuple (str, FaultInfo):
            str: Name of the PnP Service requested by PnP Server. Empty string
                upon invalid Work-Request.
            FaultInfo: An object of class FaultInfo to capture the info of a
                generated fault for sending a Fault Response back to the
                Server which typically is the source of the defect.
    """
    if not server_work_request:
        # Not supposed to happen and have been blocked by earlier check
        logger.debug("Server work request: None")
        return '', FaultInfo(pnp_fault_code['PNP_RECEIVER_FAULT'],
                             pnp_fault_string['PNP_FAULT_STR_OPERATION_FAILED'],
                             "Server work request is None")
    try:
        root = ElementTree.fromstring(server_work_request)
    except ElementTree.ParseError:
        logger.debug("Server work request: No valid element found")
        return '', FaultInfo(pnp_fault_code['PNP_SENDER_FAULT'],
                             pnp_fault_string['PNP_FAULT_STR_OPERATION_FAILED'],
                             "Server work request has no valid element")
    logger.debug("Server work request:")
    request_obscured = utils.obscure_password_in_msg(str(server_work_request))
    logger.debug(request_obscured)
    # Authenticate user and password in work-request, if required
    if auth_required and not authenticate_work_request(root.attrib):
        logger.error('Failed to authenticate work request')
        return '', FaultInfo(pnp_fault_code['PNP_SENDER_FAULT'],
                             pnp_fault_string[
                                 'PNP_FAULT_STR_AUTHORIZATION_FAILED'],
                             "Server work request failed authentication")
    for child in root.iter():
        if 'request' in child.tag:
            xmlns = child.tag
            request = xmlns[len('urn:cisco:pnp:')+1:xmlns.find('}')]
            # Sanity check if request not contain any malicious character
            # the list of malicious character can be expanded later
            if '/' in request:
                logger.warning('request %s contains malicious character',
                               request)
                fmsg = FaultInfo(pnp_fault_code['PNP_SENDER_FAULT'],
                                 pnp_fault_string[
                                     'PNP_FAULT_STR_OPERATION_FAILED'],
                                 "Server work request contains malicious "
                                 "character")
                return '', fmsg
            # Sanity check if request is one of available service on the system
            if request.strip().replace('-', '_') not in list_services():
                logger.warning('request %s is not in service list', request)
                fault_details = ("Server work request for service %s "
                                 "unavailable" %request)
                ret = '', FaultInfo(pnp_fault_code['PNP_SENDER_FAULT'],
                                    pnp_fault_string[
                                        'PNP_FAULT_STR_NOT_SUPPORTED'],
                                    fault_details)
            else:
                ret = request.strip(), ()
            return ret
    return '', ()


def extract_session_id(bye_message):
    """Extracts session ID from 'sid' element in 'bye' message from PnP Server

    Args:
        bye_message (str): XML payload for 'bye' message from Server

    Returns:
        str: Session ID extracted from 'sid' element. Empty string if no 'sid'
            element found.

    """
    root = ElementTree.fromstring(bye_message)
    for child in root.iter():
        if child.tag.endswith('sid'):
            return child.text
    return ''


def process_server_work_response(request, request_status, profile,
                                 server_work_response):
    """Parse work request from the server

    Args:
        request (str): Name of PnP Service requested by Server
        request_status (str): Status of Work-Request
        profile (Profile): PnP Profile handling this job
        server_work_response (str): XML string containing Server's Work-Response

    """
    if '<sid>' in server_work_response:
        sid = extract_session_id(server_work_response)
        if sid:
            profile.session_id = sid
    if 'bye' in server_work_response:
        pass
    profile.mark_request_done(request, request_status)


def exec_service_action(action):
    """Executes action found in Action-type object

    Args:
        action (ServiceAction): Service action to perform

    """
    if not action:
        return None
    try:
        action()
    except ServiceActionError:
        logger.exception("Encountered unhandled error while executing service "
                         "action")


def execute_requests(profile_manager):
    """Execute work request loop until there no more work to do. The map to PnP
    4-way handshake steps is described below:
    Step 1: send_work_info_request() to send starting work-info to server
    Step 2: server responses. The response will be return by
        send_work_info_request()
    Step 3: parse server response. Agent then send_work_response() to server
    Step 4: server response. Agent parse response body and if it's a bye, finish
            current request

    Args:
        profile_manager (ProfileManager): Profile Manager that will handle
            requests

    Returns:
        str: CCO Discovery result (empty string if CCO Timer expired, 'Backoff'
            if Backoff request is received from CCO, or 'Success' if non-Backoff
            request is received from CCO.

    """
    job_count = 0
    while len(profile_manager):
        # Note: Only a single PnP Profile is currently supported
        for profile_name in profile_manager:
            profile = profile_manager.get(profile_name)
            time.sleep(random.randint(2, 5))
            profile.update_conn_data()
            if not profile.correlator:
                profile.correlator = _generate_unique_correlator()
            work_request = create_work_info_request(profile)
            try:
                profile.send_work_info_request(work_request)
                job_count += 1
                logger.info("-1-> Job %d:XML Work-Req Service, Elapsed:1 ms, "
                            "Status: TimerStarted, WorkReqCorr: %s", job_count,
                            profile.correlator)
                profile.mark_request_done('server-connection',
                                          consts.SERVICE_SUCCESS)
                server_work_request = profile.server_work_request
            except PnPProfileError:
                profile.mark_request_not_done('server-connection')
                if timer.timer_status(consts.CCO_DISCOVERY_TIMER) == 'Expired':
                    logger.info("CCO Discovery Timer has expired, exiting CCO "
                                "Discovery")
                    return ''
                continue
            if not server_work_request:
                logger.debug("Did not receive response to Work-Info request")
                time.sleep(profile.callback_after)
                continue
            job_count += 1
            logger.info("<-2- Job %d:XML Work-Req Service, Elapsed:1 ms, "
                        "Status: TimerStarted, WorkReqCorr: %s", job_count,
                        profile.correlator)
            server_work_request = server_work_request.replace('xsi:', 'xsi')
            request, fault_info = process_work_request(
                profile.is_auth_required(), server_work_request)
            if not request:
                logger.debug("Failed to process work request so will move on "
                             "to the next one.")
                if not fault_info:
                    continue
            response = create_work_response(request, server_work_request,
                                            profile, fault_info)
            service_action, work_response = response
            if not work_response:
                logger.debug("Work response is None")
                current_request_status = consts.SERVICE_UNSUPPORTED
                work_response = ''
            else:
                current_request_status = consts.SERVICE_SUCCESS
            try:
                profile.send_work_response(work_response)
                job_count += 1
                logger.info("-3-> Job %d:XML %s Service, Elapsed:1 ms, Status: "
                            "TimerStarted, WorkReqCorr: %s", job_count, request,
                            profile.correlator)
                server_work_response = profile.server_work_response
            except IOError:
                profile.mark_request_not_done('server-connection')
                # assume server already receive work-response after 3 failed
                # retry and end current request
                exec_service_action(service_action)
                profile.end_profile_current_request()
                continue
            logger.info("*** Server Response ***")
            logger.info(utils.obscure_password_in_msg(server_work_response))
            if server_work_response is None:
                logger.info("None response")
                exec_service_action(service_action)
                profile.end_profile_current_request()
                continue

            job_count += 1
            logger.info("<-4- Job %d:XML %s Service, Elapsed:1 ms, Status: "
                        "TimerStarted, WorkReqCorr: %s", job_count, request,
                        profile.correlator)
            process_server_work_response(request, current_request_status,
                                         profile, server_work_response)
            if timer.timer_exists(consts.CCO_DISCOVERY_TIMER):
                if request != 'backoff':
                    exec_service_action(service_action)
                    return "Success"
                else:
                    logger.info("Backoff received from CCO Server")
                    return "Backoff"
            else:
                exec_service_action(service_action)
            #logger.debug("Call back after %d seconds", profile.callback_after)
            #time.sleep(profile.callback_after)
            profile.end_profile_current_request()
    # All profiles have been terminated
    # Enhancement: Remove termination call. Agent process should idle until new
    # profile is added.
    utils.terminate_agent()


def _generate_unique_correlator():
    """Generate a unique correlator. Correlator has the following form:
    CiscoPnP-version-index-unique uuid-profile number
    """
    unique_id = uuid.uuid4()
    global index  # pylint: disable=global-statement
    index += 1
    template = "%s-%s-%d-%s-1"
    return template % (consts.PNP_NAME, consts.PNP_VERSION, index,
                       str(unique_id))


def main():
    """main entry point for pnp agent"""
    if not utils.profile_exists():
        logger.error('Cannot start PnP Agent without a PnP Profile')
        utils.terminate_agent()
    pre_execute_requests()
    logger.info("UDI: %s", data['udi'])
    conn_info = utils.read_pnp_config()
    profile = Profile(conn_info, consts.PNP_PROFILE)
    profile.udi = data['udi']
    profile_manager = ProfileManager()
    profile_manager.add_profile(profile)
    my_url = utils.compose_url(conn_info['transport'], conn_info['address'],
                               conn_info['port'])
    logger.debug("Server Connection Address: %s", my_url)
    execute_requests(profile_manager)


def pre_execute_requests():
    """Called before execute_requests"""
    platform_dict = utils.load_platform_info()
    if not platform_dict:
        logger.error("Unable to load platform information")
        sys.exit(1)
    global data  # pylint: disable=global-variable-not-assigned
    data['udi'] = platform_dict['udi']['primary-chassis']
    if 'macAddress' in platform_dict:
        data['macaddr'] = platform_dict['macAddress']

def set_pnp_to_lead_proc_gp():
    """This function seeks to set a new session ID for this agent process so
    that in such doing when it's not yet the leader of its process group it'll
    be made so.
    It's fine if this attempt fails because such failure can only occur when
    it's already the leader of its process group.
    The need to have this agent process to head its process group is due to the
    case when the agent is started via NFVIS' confD command to start PnP. In
    that case, confD and this agent process will be put into the same process
    group.  Upon PnP stop, it'll seek to kill its process group to kill all its
    subprocesses. Thus, this'll get confD killed also!!!  Having the agent
    process head its own process group can prevent this from happening.
    """
    # Record the old proc info before the change
    my_pid = getpid()
    old_pgid = getpgid(my_pid)

    # Call os.setsid() to create a new session & set this agent process' PID
    # as the new proc group ID.
    # Note that the return value of setsid() we don't care. Typically it's
    # NULL.  In cases not so, it'll give -1 upon failure.  But failure occurs
    # only when this agent process is already the leader of its process group.
    # In that case, not having its process group ID changed is fine.
    setsid()

    # Display the process info change in debug after the change attempt
    new_pgid = getpgid(my_pid)
    logger.debug("Agent's PID: %d; process group ID change: %d -> %d",
                 my_pid, old_pgid, new_pgid)

if __name__ == '__main__':
    pnp_logging.initiate_logging()
    logger = getLogger('pnp.agent')
    logger.info("PnP Agent Version: %s; Platform: %s; Platform Version: %s",
                consts.PNP_VERSION, consts.PNP_PLATFORM,
                consts.PNP_PLATFORM_VERSION)
    logger.debug("PnP Agent started by user: %s", getuser())
    set_pnp_to_lead_proc_gp()
    try:
        if not pnp.discovery.infra.discovery_manager.discovery_manager():
            logger.info("PnP Discovery did not produce a PnP Profile; "
                        "exiting Agent...")
            utils.terminate_agent()
    except Exception:  # pylint: disable=broad-except
        logger.exception("Encountered an unexpected error during PnP Discovery")
        utils.terminate_agent()
    main()
