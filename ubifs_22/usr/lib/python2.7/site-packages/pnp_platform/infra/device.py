################################################################################
# Copyright (c) 2015-17 by Cisco Systems, Inc.
# All rights reserved.
#
# Author: Shaurin Desai <shaurdes@cisco.com>
################################################################################
"""PnP Infra Device API implementation

This implementation will call mock functions to handle some Device API calls.
For instance, the Device.udi() classmethod will generate a random UDI to use.  

"""
import json
import os
import platform
from random import randint

from pnp_platform import __version__

from pnp.infra.api.pnp_infra import PnPInfra, SEVERITY_WARNING

from pnp.infra.utils.pnp_file_paths import filepaths


class Device(PnPInfra):
    """Device API implementation
    """

    _udi = ''
    _hardware_info = dict()
    _image_info = dict()

    @classmethod
    def udi(cls):
        """Provides primary-chassis UDI.

        Returns:
            str: UDI string in this format: "PID:<PID>,VID:<VID>,SN:<SN>".

        """
        # should populate the _UDI attribute upon first call
        if not cls._udi:
            udi_str = "PID:{pid},VID:{vid},SN:{sn}"
            platform_id = 'POSIX-Reference'
            version_id = 'V01'
            serial_num = _random_with_n_digits(11)
            cls._udi = udi_str.format(pid=platform_id, vid=version_id,
                                      sn=serial_num)
        return cls._udi

    @classmethod
    def filesystem_info(cls):
        """Provides current status of filesystem(s) present on the system. Since
        this function provides dynamic values, the return value should NOT be
        stored in an attribute for future method calls.

        Returns:
            list(dict): List of dictionaries in the following format:
                [{'fileSystem':
                    {
                        '@writeable': (bool),
                        '@type': (str),  # possible values: 'flash' or 'nvram'
                        '@size': (int),
                        '@readable': (bool),
                        '@name': (str),  # values: 'bootflash' or 'nvram'
                        '@freespace': (int)
                    }
                }, ...]

        """
        filesystems = []
        filesystem_size, filesystem_freespace = _get_filesystem_info()
        filesystem = {
            '@writeable': True,
            '@type': 'nvram',
            '@size': filesystem_size,
            '@readable': True,
            '@name': 'nvram',
            '@freespace': filesystem_freespace
        }
        filesystems.append({'fileSystem': filesystem})
        return filesystems

    @classmethod
    def hardware_info(cls):
        """Provides information on the device's hardware. Some hardware info
        fields may not be relevant to all platforms.
        
        Note:
            Not all hardware info fields will be populated since not all fields
            are relevant to the reference platform.

        Returns:
            dict: Dictionary must contain the following key-value pairs:
                hardware_info_dict = {
                    'hostname': (str, optional),
                    'vendor': (str, optional),
                    'platformName': (str, optional),
                    'processorType': (str, optional),
                    'hwRevision': (str, optional),
                    'mainMemSize': (int, optional),
                    'ioMemSize': (int, optional),
                    'boardId': (int, optional),
                    'boardReworkId': (str, optional),
                    'processorRev': (str, optional),
                    'midplaneVersion': (str, optional),
                    'location': (str, optional),
                    'deviceType': (str, optional)  # only possible value is 'AP'
                }

        """
        # should populate the _hardware_info attribute upon first call
        if not cls._hardware_info:
            cls._hardware_info = {
                'hostname': platform.node(),
                'vendor': 'Network-PnP',
                'platformName': 'reference',
                'processorType': platform.machine(),
            }
        return cls._hardware_info

    @classmethod
    def image_info(cls):
        """Provides information on the device's current image. Some image info
        fields may not be relevant to all platforms. The image version, or OS
        version, MUST be included in the return dictionary.

        Returns:
            dict: Dictionary must contain the following key-value pairs:
                image_info_dict = {
                    'versionString': (str),
                    'returnToRomReason': (str, optional),
                    'bootVariable': (str, optional),
                    'bootLdrVariable': (str, optional),
                    'configVariable': (str, optional),
                    'configReg': (str, optional),
                    'configRegNext': (str, optional)
                }

        """
        # should populate the _image_info attribute upon first call
        if not cls._image_info:
            cls._image_info = {'versionString': __version__}
        return cls._image_info

    @classmethod
    def get_device_info(cls):
        """Provides device information.

        API has not been enabled by pnp module yet.

        Returns:
            dict: Device Info dictionary in the following format:
                {
                    'udi': (str),  # cls._udi
                    'fileSystemList': (list(dict)),  # cls.filesystem_info()
                    'hardwareInfo': (dict),  # cls._hardware_info
                    'imageInfo': (dict)  # cls._image_info
                }
        """
        """
        device_info = {
            'udi': cls.udi(),
            'fileSystemList': cls.filesystem_info(),
            'hardwareInfo': cls.hardware_info(),
            'imageInfo': cls.image_info()
        }
        return device_info
        """

        """copy legacy _load_platform_info from PI pnp_utils.py
        consider use the above API later
        """
        platform_file = filepaths['config']['platform']
        try:
            with open(platform_file) as f:
                platform = json.load(f)
        except (IOError, AttributeError, ValueError):
            logger.exception("Failed to load platform info")
            return None
        return platform

def _random_with_n_digits(n):
    range_start = 10**(n-1)
    range_end = (10**n)-1
    return randint(range_start, range_end)


def _get_filesystem_info():
    statvfs = os.statvfs('/')
    total_space = statvfs.f_frsize * statvfs.f_blocks
    available_space = statvfs.f_frsize * statvfs.f_bavail
    return total_space, available_space
