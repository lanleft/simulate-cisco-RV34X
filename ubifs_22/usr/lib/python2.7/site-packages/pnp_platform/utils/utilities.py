"""
generate cmd shared by different services
"""
import logging
import re
import os
import subprocess
from ConfigParser import SafeConfigParser

import pnp.infra.utils.pnp_file_paths as files

logger = logging.getLogger(__name__)


def tftp_download(src):
    """tftp download"""
    src_list = re.split(r'\/*', src)
    ip_addr = src_list[1]
    base_name = src_list[-1]
    full_name = os.path.join('/tmp', base_name)
    logger.info("full_name " + full_name)
    return ('cd /tmp; tftp -g -r ' + base_name + ' ' + ip_addr, full_name)

def http_download(src):
    """http and https download"""
    config = SafeConfigParser()
    config.read(files.filepaths['config']['pnp'])
    if config.has_section('Profile 1'):
        transport = config.get('Profile 1', 'transport')
        ip_or_name = config.get('Profile 1', 'address')
        port = config.get('Profile 1', 'port')
        cafile = config.get('Profile 1', 'cafile')
        logger.debug('PnP server transport protocol: ' + transport)
        logger.debug('PnP server ip or name: ' + ip_or_name)
        logger.debug('PnP server port: ' + port)
        logger.debug('PnP server cafile: ' + cafile)
        if transport == '':
            logger.error('PnP server transport is not defined!')
            raise KeyError("trasnport")
        if ip_or_name == '':
            logger.error('PnP server ip is not defined!')
            raise KeyError("ip")
        if transport == 'http':
            src_list = re.split(r'\/*', src)
            base_name = src_list[-1]
            full_name = os.path.join('/tmp', base_name)
            logger.debug("full_name " + full_name)
            return ('cd /tmp; curl -O http://' + ip_or_name + ':' + port + '/' + src, full_name)
        if transport == 'https':
            src_list = re.split(r'\/*', src)
            base_name = src_list[-1]
            full_name = os.path.join('/tmp', base_name)
            logger.debug("full_name " + full_name)
            #return ('cd /tmp; curl -kO https://' + ip_or_name + ':' + port + '/' + src, full_name)
            if cafile == '' or cafile == 'default':
                return ('cd /tmp; curl -O https://' + ip_or_name + ':' + port + '/' + src, full_name)
            else:
                return ('cd /tmp; curl --cacert ' + cafile + ' -O https://' + ip_or_name + ':' + port + '/' + src,
                    full_name)
        logger.error("PnP server not supported transport protocol: " + transport)
        raise ValueError(transport)
    logger.error('No Profile 1')
    raise KeyError

def download_cmd(src):
    """download cmd"""
    cmd_map = {
        'tftp':tftp_download,
        'http':http_download,
    }
    src_list = re.split(r'\/*', src)
    protocol = src_list[0]
    try:
        cmd_map[protocol]
    except KeyError:
        logger.info('use http as download protocol')
        protocol = 'http'
    return cmd_map[protocol](src)

def is_started_with_pattern(pattern, string):
    """
    This function checks whether a pattern is contained in a string
    """
    pat = re.compile(pattern)
    return pat.match(string)

def _bb2_reboot_2(delay):
    subprocess.call('reboot_to_image.sh inactive && reboot -d ' + str(delay), shell=True)

def _pp_reboot_2(delay):
    subprocess.call('reboot_to_image.sh inactive && reboot -d ' + str(delay), shell=True)

def reboot_action_2(pid, delay):
    """reboot cmd"""
    if is_started_with_pattern("RV26", pid):
        return _pp_reboot_2(delay)
    elif is_started_with_pattern("RV16", pid):
        return _pp_reboot_2(delay)
    elif is_started_with_pattern("RV34", pid):
        return _bb2_reboot_2(delay)

def reboot_action(pid, delay):
    subprocess.call('reboot -d ' + str(delay), shell=True)

def save_config_cmd():
    """save config cmd"""
    return 'config_mgmt.sh copy config-running config-startup'

if __name__ == '__main__':
    pass
