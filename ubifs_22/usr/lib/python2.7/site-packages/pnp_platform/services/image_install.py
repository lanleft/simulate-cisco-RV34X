################################################################################
# Copyright (c) 2015-17 by Cisco Systems, Inc.
# All rights reserved.
#
# Author: Xinsheng Fang <xinsfang@cisco.com> 
################################################################################
"""PnP Service: Image-Install

"""
import re
import subprocess
import hashlib

from pnp_platform.utils.utilities import (download_cmd,
                                          is_started_with_pattern,
                                          reboot_action_2,
                                          save_config_cmd)

from pnp.infra.utils.pnp_utils import load_platform_info
from pnp.service.api.pnp_service import PnPService, ServiceAction


class ImageInstall(PnPService):
    """Services Install service
    """
    pid = load_platform_info().get('pid', '')
    src = ''
    checksum = ''

    reload_delay_in = ''
    reload_save_config = ''
    reload_reason = ''
    reload_user = ''

    local_image_name = ''

    def run(self):
        assert self.pid
        try:
            source = self.request['image']['copy']['source']
            self.src = source.get('location') or source.get('uri')
            source = self.request['image']['copy']['source']
            self.checksum = source.get('checksum')
            #We ignore dst, since we store image at ram disk /tmp.
            #We download image, apply it and reboot.
            #After reboot, image file is lost.
            #self.dst = self.request['image']['copy']['destination']
            #.get('location', '/tmp')

            self.reload_reason = self.request['reload']['reason']
            self.reload_delay_in = self.request['reload'].get('delay_in', '20')
            self.reload_user = self.request['reload']['user']
            self.reload_save_config = self.request['reload'].get('save_config', True)

            self.logger.info("source location: %s", self.src)
            #self.logger.info("destination location: %s", self.dst)
            self.logger.info("checksum: %s", self.checksum)
        except KeyError as err:
            self.logger.error('image-install error accessing ' + str(err))
            self.success = 0
            self.set_error_info(code='INTERNAL', msg="Failed to parse request")
        try:
            cmd = save_config_cmd()
            retcode = subprocess.call(cmd, shell=True)
            if retcode != 0:
                self.logger.error("unable to save config")
                self.success = 0
                self.set_error_info(severity='ERROR',
                                    code='STARTUP_CFG_COPY_FAILED',
                                    msg="Error save config")
                return
            (cmd, local_image_name) = download_cmd(self.src)
            self.local_image_name = local_image_name
            #self.logger.info("Will download " + cmd)
            retcode = subprocess.call(cmd, shell=True)
            if retcode != 0:
                self.logger.error("unable to download image")
                self.success = 0
                self.set_error_info(severity='ERROR',
                                    code='NO_SPACE_ON_DEST_FS',
                                    msg="Error download image")
                return
            checksum = hashlib.md5(open(self.local_image_name,
                                        'rb').read()).hexdigest()
            self.logger.info("md5 is "+ checksum)
            #APIC EM does not send md5. Not sure if it is mandatory
            if self.checksum and checksum != self.checksum:
                self.logger.info("checksum does not match")
                self.success = 0
                self.set_error_info(severity='ERROR', code='INTERNAL',
                                    msg="Checksum mismatch!")
                return
            cmd = self._fw_upgrade_cmd()
            assert cmd
            self.logger.info("Will upgrade image. cmd: " + cmd)
            proc = subprocess.Popen(cmd, shell=True,
                                    stdout=subprocess.PIPE,
                                    stderr=subprocess.STDOUT,
                                    stdin=subprocess.PIPE)
            out, _ = proc.communicate()
            retcode = proc.poll()
            self.logger.debug("stdout is: " + out)
            self.logger.debug("retcode is: " + str(retcode))
            if retcode or re.search('error', out, flags=re.IGNORECASE):
                self.logger.error("unable to apply image")
                self.success = 0
                self.set_error_info(severity='ERROR',
                                    code='IMG_SIGNATURE_NOT_VALID',
                                    msg="Error apply image")
                return
            self.logger.info("Will reboot system in " +  self.reload_delay_in)
            action_args = [self.pid, self.reload_delay_in]
            self.action = ServiceAction(reboot_action_2, 'reboot_2', *action_args)
            self.success = 1
            return
        except Exception as err: #pylint:disable=broad-except
            self.logger.exception("Image Install failed")
            self.success = 0
            self.set_error_info(severity='ERROR', code='INTERNAL',
                                msg=str(err))
            return

    def _bb2_fw_upgrade(self):
        return 'rv340_fw_unpack.sh ' + self.local_image_name

    def _pp_fw_upgrade(self):
        return 'rv16x_26x_fw_unpack.sh ' + self.local_image_name

    def _fw_upgrade_cmd(self):
        if is_started_with_pattern("RV26", self.pid):
            return self._pp_fw_upgrade()
        elif is_started_with_pattern("RV16", self.pid):
            return self._pp_fw_upgrade()
        elif is_started_with_pattern("RV34", self.pid):
            return self._bb2_fw_upgrade()
        else:
            self.logger.error('Cannot find pid: ' + self.pid)
