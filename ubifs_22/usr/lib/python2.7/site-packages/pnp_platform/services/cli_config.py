################################################################################
# Copyright (c) 2015-17 by Cisco Systems, Inc.
# All rights reserved.
#
# Author: Xinsheng Fang <xinsfang@cisco.com>
################################################################################
"""PnP Service: CLI-Exec

This module is not tested!
"""

import re
import subprocess
import unicodedata

from pnp.service.api.pnp_service import PnPService
import pnp.infra.utils.pnp_file_paths as files


class CLIConfig(PnPService):
    """CLI-Config"""
    
    def run(self):
        self.response['resultEntry'] = {}
        self.response['resultEntry']['text'] = ''
        self.success = 0
        self.cmd = ''
        cmd_map = {
            'set ':self.__confd_cmds,
            'edit ':self.__confd_cmds,
            #    '.*':self.__linux_cmd
        }
        self.rd = regex_dict(cmd_map)
        try:
            self.cmd = self.request['configApply']['config-data']['cli-config-data']['cmd']
            self.logger.info('cli-config cmd is %s', self.cmd)
        except KeyError:
            self.logger.exception('cli-config error accessing config-data cmd')
            return
        cmds = self.__get_exec_cmds()
        for cmd in cmds:
            self.logger.info('Will execute cmd: ' + ' '.join(cmd))
            try:
                proc = subprocess.Popen(cmd, shell=False,
                                        stdout=subprocess.PIPE,
                                        stderr=subprocess.STDOUT,
                                        stdin=subprocess.PIPE)
                out, err = proc.communicate()
                retcode = proc.poll()
                self.logger.debug("stdout is: " + out)
                self.response['resultEntry']['text'] += out
                if retcode or re.search('error', out, flags=re.IGNORECASE):
                    self.logger.error("unable to execuate a cli: " + ' '.join(cmd))
                    self.success = 0
                    return
            except Exception:
                self.logger.exception("unable to execuate a cli: " + ' '.join(cmd))
                self.success = 0
                self.response['resultEntry']['text'] = out
                return

        self.response['resultEntry']['text'] = out
        self.success = 1
        return

    def __confd_cmds(self, c):
        cmd_file = '/tmp/pnp_cmd_tmp'
        try:
            f=open(cmd_file, 'w')
        except IOError:
            self.logger.error("file open error: %s", cmd_file)
            r = ['exit', '1']
        f.truncate()
        f.write('configure\n')
        f.write(c + '\n')
        f.write('commit\n')
        f.write('exit no-confirm\n')
        f.write('exit\n')
        f.close()
        r = ['confd_cli', '--noninteractive', cmd_file]
        self.logger.debug("confd_cmds")
        return r

    def __get_exec_cmds(self):
        #self.cmd pattern is u'cmd' or [u'cmd1',u'cmd2']
        if hasattr(self.cmd, '__iter__') and not isinstance(self.cmd, str):
            self.logger.info("cli_exec reveives more than one command from server!")
            for cmd in self.cmd:
                yield self.__get_exec_cmd(cmd)
        else:
            yield self.__get_exec_cmd(self.cmd)

    def __ifconfig_cmd(self, c):
        self.logger.info("Not supported cmd: " + c)
        return ['ifconfig']

    def __get_exec_cmd(self, c):
        self.logger.info("c is %s", c)
        c = unicodedata.normalize('NFKD', c).encode('ascii', 'ignore')
        o = self.rd.get_matching(c)
        if o:
            self.logger.debug("match in cmd dict: " + c)
            return o(c)
        else:
            self.logger.debug("did not find matching in cmd dict!")
#            return self.__linux_cmd(c)
            return self.__ifconfig_cmd(c)

class regex_dict(dict):
    def get_matching(self, event):
        for key in self:
            if re.match(key, event):
                return self[key]
        return None
#        return (self[key] for key in self if re.match(key, event))
