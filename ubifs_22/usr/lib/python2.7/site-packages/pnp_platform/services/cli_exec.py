################################################################################
# Copyright (c) 2015-17 by Cisco Systems, Inc.
# All rights reserved.
#
# Author: Xinsheng Fang <xinsfang@cisco.com>
################################################################################
"""PnP Service: CLI-Exec

"""
import re
import subprocess
import unicodedata

import pnp.infra.utils.pnp_file_paths as files
from pnp.service.api.pnp_service import PnPService


class CLIExec(PnPService):
    """CLI-Exec
    """

    def run(self):
        self.response['execLog'] = {}
        self.response['execLog']['dialogueLog'] = {}
        self.response['execLog']['dialogueLog']['received'] = {}
        self.response['execLog']['dialogueLog']['received']['text'] = ''
        self.success = 0
        self.cmd = ''
        cmd_map = {
            'show run':self.__ifconfig_cmd,
            'show ip':self.__ifconfig_cmd,
            'sh version':self.__ifconfig_cmd,
            'show ':self.__confd_cmds,
            'configure ':self.__confd_cmds,
            'compare ':self.__confd_cmds,
            'file ':self.__confd_cmds,
            #    '.*':self.__linux_cmd
        }
        self.rd = regex_dict(cmd_map)
        try:
            self.cmd = self.request['execCLI'].get('cmd')
            self.response['execLog']['dialogueLog']['sent'] = self.cmd
            self.logger.info('cli-exec service will execute %s', self.cmd)
        except KeyError:
            err_msg = 'cli-exec error accessing execCLI cmd'
            self.logger.exception(err_msg)
            self.set_error_info(severity='ERROR', code='INTERNAL',
                                msg=err_msg)
            return
        if self.cmd == 'show ip interface brief' or self.cmd == 'sh version | inc uptime' or self.cmd == 'show run | sec pnp profile':
            self.response['execLog']['dialogueLog']['received']['text']= '''\
            Interface              IP-Address      OK? Method Status                Protocol
GigabitEthernet0/0/0   unassigned      YES unset  administratively down down
GigabitEthernet0/0/1   unassigned      YES unset  administratively down down
GigabitEthernet0/0/2   unassigned      YES unset  administratively down down
GigabitEthernet0/0/3   unassigned      YES unset  administratively down down
GigabitEthernet0       unassigned      YES unset  administratively down down
Vlan1                  unassigned      YES unset  administratively down down
            It is needed if integrated with APIC EM '''
            self.success = 1
            return

        cmds = self.__get_exec_cmds()
        for cmd in cmds:
            self.logger.info('Will execute cmd: ' + ' '.join(cmd))
            try:
                proc = subprocess.Popen(cmd, shell=False,
                                        stdout=subprocess.PIPE,
                                        stderr=subprocess.STDOUT,
                                        stdin=subprocess.PIPE)
                out, err = proc.communicate()
                retcode = proc.poll()
                self.logger.info("stdout is: " + out)
                self.response['execLog']['dialogueLog']['received']['text'] += out
                if retcode or re.search('error', out, flags=re.IGNORECASE):
                    self.logger.error("unable to execuate a cli: " + ' '.join(cmd))
                    self.success = 0
                    return
            except Exception:
                self.logger.exception("unable to execuate a cli: " + ' '.join(cmd))
                self.success = 0
                self.response['execLog']['dialogueLog']['received']['text'] = out
                return

        self.response['execLog']['dialogueLog']['received']['text'] = out
        self.success = 1
        return

    def __confd_cmds(self, c):
        cmd_file = '/tmp/pnp_cmd_tmp'
        try:
            f=open(cmd_file, 'w')
        except IOError:
            self.logger.error("file open error: %s", cmd_file)
            r = ['exit', '1']
        f.truncate()
        f.write(c + '\n')
        f.close()
        r = ['confd_cli', '--noninteractive', cmd_file]
        self.logger.debug("confd_cmds")
        return r

    def __linux_cmd(self,c ):
        r = re.split('[ \t]+', c)
        return r

    def __get_exec_cmds(self):
        #self.cmd pattern is u'cmd' or [u'cmd1',u'cmd2']
        if hasattr(self.cmd, '__iter__') and not isinstance(self.cmd, str):
            self.logger.info("cli_exec reveives more than one command from server!")
            for cmd in self.cmd:
                yield self.__get_exec_cmd(cmd)
        else:
            yield self.__get_exec_cmd(self.cmd)

    def __ifconfig_cmd(self, c):
        self.logger.info("Not supported cmd: " + c)
        return ['ifconfig']

    def __get_exec_cmd(self, c):
        self.logger.info("c is %s", c)
        c = unicodedata.normalize('NFKD', c).encode('ascii', 'ignore')
        o = self.rd.get_matching(c)
        if o:
            self.logger.debug("match in cmd dict: " + c)
            return o(c)
        else:
            self.logger.debug("did not find matching in cmd dict!")
#            return self.__linux_cmd(c)
            return self.__ifconfig_cmd(c)

class regex_dict(dict):
    def get_matching(self, event):
        for key in self:
            if re.match(key, event):
                return self[key]
        return None
#        return (self[key] for key in self if re.match(key, event))
