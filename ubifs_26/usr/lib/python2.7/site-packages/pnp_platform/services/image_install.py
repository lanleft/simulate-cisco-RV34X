################################################################################
# Copyright (c) 2015-17 by Cisco Systems, Inc.
# All rights reserved.
#
# Author: Shaurin Desai <shaurdes@cisco.com>
# Author: Xinsheng Fang <xinsfang@cisco.com>
################################################################################
"""PnP Service: Image-Install

Reference implementation for Image-Install service. This service will download
an image file to a temporary location, before calling a platform script to
validate and install the image. After image installation, the device will be
reloaded (or simulated in the reference example).

Note:
    This service will vary across platforms, since each platform could expect
    different types of image files or formats. Some platforms may require an
    image bundle or multiple image files, which is not directly supported by the
    service schema. Also, some schema elements may not be relevant for certain
    platforms, so those elements should be handled as no-ops.

"""
import hashlib
import os
import shutil
import urllib2
from contextlib import closing
import re
import subprocess
import xml.etree.ElementTree as ET

from pnp.infra.network.security import load_csdl_ssl_context
from pnp.infra.utils.pnp_utils import compose_url, read_pnp_config
from pnp.service.api.pnp_service import PnPService, ServiceAction
from pnp.infra.utils.pnp_utils import load_platform_info

from pnp_platform.utils.utilities import (is_started_with_pattern,
                                          reboot_action_2,
                                          save_config_cmd)

class ImageInstallError(Exception):
    """Image Install Error (inherits from Exception)"""
    pass


class ImageInstall(PnPService):
    """Image Install implementation
    """

    _destination = '/tmp/pnp_image_install'
    _pid = None

    def run(self):
        """Populates the Image-Install Work-Response and sets service action."""
        try:
            self._pid = load_platform_info().get('pid')
            self._download_image()
            # Compare downloaded file against 'checksum' element (if specified)
            self._validate_checksum()
            # Install image
            self._install_image()
            # Enable ServiceAction for reloading if requested
            self._check_reload()
            # Service ran successfully
            self.success = 1
        except ImageInstallError:
            self.logger.exception("Image Install failure")
            self.success = 0

    def _download_image(self):
        """Download the image file to a temporary location or one specified in
        the request.
        """
        # Form download url based off 'location' or 'uri' element
        ssl_context = None
        if 'location' in self.request['image']['copy']['source']:
            src = self.request['image']['copy']['source']['location']
            # Generate SSL Context with broader trust scope for location source
            if 'https' in src:
                profile = read_pnp_config()
                kwargs = {'cafile_': profile.get('cafile')}
                          #'core_trustpool': profile.get('core_trustpool'),
                          #'full_trust_store': True}
                ssl_context = load_csdl_ssl_context(**kwargs)
        else:
            profile = read_pnp_config()
            transport = profile['transport']
            address = profile['address']
            port = profile['port']
            # Generate SSL Context with limited trust scope for URI source
            if transport == 'https':
                kwargs = {'cafile_': profile.get('cafile')}
                          #'core_trustpool': profile.get('core_trustpool'),
                          #'full_trust_store': False}
                ssl_context = load_csdl_ssl_context(**kwargs)
            uri = self.request['image']['copy']['source']['uri']
            url = compose_url(transport, address, port)
            src = '%s%s' % (url, uri)

        # Form download destination
        if 'destination' in self.request['image']['copy']:
            dest_elem = self.request['image']['copy']['destination']
            if 'location' in dest_elem:
                self._destination = dest_elem['location']
            else:
                self._destination = dest_elem['uri']

        # Download Image
        self.logger.debug("Downloading image from: %s", src)
        try:
            with closing(urllib2.urlopen(src, context=ssl_context)) as image:
                with open(self._destination, 'wb') as dest:
                    shutil.copyfileobj(image, dest)
        except Exception as err:
            self.set_error_info(msg="Failed to download image")
            raise ImageInstallError(err)

    def _validate_checksum(self):
        """Raises ImageInstallError upon checksum mismatch"""
        if 'checksum' not in self.request['image']['copy']['source']:
            return
        expected_checksum = self.request['image']['copy']['source']['checksum']
        with open(self._destination, 'rb') as image_file:
            actual_checksum = hashlib.md5(image_file.read()).hexdigest()
        if actual_checksum != expected_checksum:
            self.set_error_info(msg="Checksum mismatch!")
            raise ImageInstallError("Bad Checksum: %s" % actual_checksum)

    def _install_image(self):
        """Performs no-op since image install is not supported on reference
        platform.
        """
        self.logger.info("Installing image: " + self._destination)
        cmd = ''
        if is_started_with_pattern("RV26", self._pid):
            cmd = 'rv16x_26x_fw_unpack.sh ' + self._destination
        elif is_started_with_pattern("RV16", self._pid):
            cmd = 'rv16x_26x_fw_unpack.sh ' + self._destination
        elif is_started_with_pattern("RV34", self._pid):
            cmd = 'rv340_fw_unpack.sh ' + self._destination
        else:
            self.set_error_info(msg="Unknown PID!")
            raise ImageInstallError("Bad PID: %s" % self._pid)
        self.logger.info("Upgrade image cmd: " + cmd)
        proc = subprocess.Popen(cmd, shell=True,
                                stdout=subprocess.PIPE,
                                stderr=subprocess.STDOUT,
                                stdin=subprocess.PIPE)
        out, _ = proc.communicate()
        retcode = proc.poll()
        self.logger.debug("stdout is: " + out)
        self.logger.debug("retcode is: " + str(retcode))
        if retcode or re.search('error', out, flags=re.IGNORECASE):
            self.set_error_info(severity='ERROR',
                                code='IMG_SIGNATURE_NOT_VALID',
                                msg="Error apply image")
            raise ImageInstallError("Bad image")

    def _check_reload(self):
        if 'reload' not in self.request:
            return
        save_config = self.request['reload'].get('save_config', True)
        if save_config:
            self.logger.info("Saving running config")
            self._system_save_config()
        if 'reason' in self.request['reload']:
            self.logger.info("Reloading device: %s",
                             self.request['reload']['reason'])
        delay_in = self.request['reload'].get('delayIn', 'now')
        if not re.match(r'^[0-9]+$|^now$', delay_in):
            self.set_error_info(severity='ERROR', code='RELOAD_INPUT_ERROR',
                                msg='PnP - Error reload delayIn')
            raise ImageInstallError("Bad reload delayIn")
        reload_args = [self._pid, delay_in]
        self.action = ServiceAction(_reload_platform, 'reload', *reload_args)

    def _system_save_config(self):
        cmd = save_config_cmd()
        retcode = subprocess.call(cmd, shell=True)
        if retcode != 0:
            self.set_error_info(severity='ERROR',
                                code='STARTUP_CFG_COPY_FAILED',
                                msg="Error save config")
            raise ImageInstallError("Error save config")

def _reload_platform(*args):
    """Issues reboot command"""
    reboot_action_2(*args)

