################################################################################
# Copyright (c) 2015-17 by Cisco Systems, Inc.
# All rights reserved.
#
# Author: Shaurin Desai <shaurdes@cisco.com>
# Author: Xinsheng Fang <xinsfang@cisco.com>
################################################################################
"""PnP Service: Config-Upgrade

Reference implementation for Config-Upgrade service. This service will download
a configuration file to temporary location, before calling a platform script to
validate and apply the configuration file.

Note:
    This service will vary across platforms, since each platform can have a
    different type of configuration database or accept different types of
    configuration files or formats. Some schema elements may not be relevant for
    certain platforms, so those elements should be handled as no-ops.

"""
import re
import codecs
import hashlib
import os
import urllib2
import subprocess
import xml.etree.ElementTree as ET

from pnp.infra.network.security import load_csdl_ssl_context
from pnp.infra.utils.pnp_utils import compose_url, read_pnp_config
from pnp.service.api.pnp_service import PnPService, ServiceAction
from pnp.infra.utils.pnp_utils import load_platform_info

from pnp_platform.utils.utilities import reboot_action

class ConfigUpgradeError(Exception):
    """Config Upgrade Error (inherits from Exception)"""
    pass


class ConfigUpgrade(PnPService):
    """Config Upgrade implementation
    """

    _download_path = '/tmp/pnp_config_upgrade'
    _pid = None

    def run(self):
        """Populates the Config-Upgrade Work-Response"""
        try:
            self._pid = load_platform_info().get('pid')
            self._download_config()
            # Compare downloaded file against 'checksum' element (if specified)
            self._validate_checksum()
            # Apply config based off value in 'applyTo' element and handle
            # syntax fault
            self._apply_config()
            # Enable ServiceAction for reloading if requested
            self._check_reload()
            # Service ran successfully
            self.success = 1
        except ConfigUpgradeError:
            self.logger.exception("Config Upgrade failure")
            self.success = 0

    def _download_config(self):
        """Download the config file to a temporary location"""
        # Form download url based off 'location' or 'uri' element
        ssl_context = None
        if 'location' in self.request['config']['copy']['source']:
            src = self.request['config']['copy']['source']['location']
            # Generate SSL Context with broader trust scope for location source
            if 'https' in src:
                profile = read_pnp_config()
                kwargs = {'cafile_': profile.get('cafile')}
                          #'core_trustpool': profile.get('core_trustpool'),
                          #'full_trust_store': True}
                ssl_context = load_csdl_ssl_context(**kwargs)
        else:
            profile = read_pnp_config()
            transport = profile['transport']
            address = profile['address']
            port = profile['port']
            # Generate SSL Context with limited trust scope for URI source
            if transport == 'https':
                kwargs = {'cafile_': profile.get('cafile')}
                          #'core_trustpool': profile.get('core_trustpool'),
                          #'full_trust_store': False}
                ssl_context = load_csdl_ssl_context(**kwargs)
            uri = self.request['config']['copy']['source']['uri']
            url = compose_url(transport, address, port)
            src = '%s%s' % (url, uri)
        # Download config
        self.logger.debug("Downloading config file from: %s", src)
        req = urllib2.Request(url=src.encode('utf-8'))
        req.add_header('Content-Type', 'text/xml')
        req.add_header('Accept-Charset', 'utf-8')
        try:
            config = urllib2.urlopen(req, context=ssl_context, timeout=30)
        except Exception as err:
            self.set_error_info(code='INVALID_SRC_CONFIG_FILE',
                                msg="Failed to download config")
            raise ConfigUpgradeError(err)
        try:
            with codecs.open(self._download_path, 'w', 'utf-8') as fout:
                string_out = config.read()
                fout.write(string_out.encode('ascii', 'ignore'))
        except Exception as err:
            err_msg = "Failed to write downloaded config to the filesystem"
            self.set_error_info(msg=err_msg)
            raise ConfigUpgradeError(err)

    def _validate_checksum(self):
        """Raises ConfigUpgradeError upon checksum mismatch"""
        if 'checksum' not in self.request['config']['copy']['source']:
            return
        expected_checksum = self.request['config']['copy']['source']['checksum']
        with open(self._download_path, 'rb') as config_file:
            actual_checksum = hashlib.md5(config_file.read()).hexdigest()
        if actual_checksum != expected_checksum:
            self.set_error_info(msg="Checksum mismatch!")
            raise ConfigUpgradeError("Bad Checksum: %s" % actual_checksum)

    def _apply_config(self):
        """Applies config to system"""
        apply_to = self.request['config']['copy'].get('applyTo', 'startup')
        abort_on_fault = 'abortOnSyntaxFault' in self.request['config']['copy']
        # reference platform doesn't support configurations, will perform no-op
        try:
            self._system_apply_config(self._download_path, apply_to, abort_on_fault)
        except Exception as err:
            self.set_error_info(msg="Failed to apply config")
            raise ConfigUpgradeError(err)

    def _check_reload(self):
        if 'reload' in self.request:
            if 'reason' in self.request['reload']:
                self.logger.info("Reloading device: %s",
                                 self.request['reload']['reason'])
            delay_in = self.request['reload'].get('delayIn', 'now')
            if not re.match(r'^[0-9]+$|^now$', delay_in):
                self.set_error_info(severity='ERROR', code='RELOAD_INPUT_ERROR',
                                    msg='PnP - Error reload delayIn')
                raise ConfigUpgradeError("Bad reload delayIn")
            reload_args = [self._pid, delay_in]
            self.action = ServiceAction(_reload_platform, 'reload', *reload_args)

    def _system_apply_config(self, config, dest, abort_on_fault):  # pylint: disable=unused-argument
        """Simulates applying config"""
        self.logger.info("Applying downloaded config (%s) to %s config", config, dest)
        if abort_on_fault:
            self.logger.info("Will abort config application on syntax fault")
        cli = _rv340_config_upgrade_cli(config, dest)

        self.logger.info("Will do config upgrade. cli: " + cli)
        proc = subprocess.Popen(cli, shell=True,
                                stdout=subprocess.PIPE,
                                stderr=subprocess.STDOUT,
                                stdin=subprocess.PIPE)
        stdout, _ = proc.communicate()
        retcode = proc.poll()
        self.logger.info("stdout is: " + stdout)
        self.logger.debug("retcode is: " + str(retcode))
        if retcode or re.search('error', stdout, flags=re.IGNORECASE):
            self.set_error_info(severity='ERROR', code='APPLY_CFG_REQ_ERROR',
                                msg='PnP - Error apply config')
            raise ConfigUpgradeError('apply config')


def _rv340_config_upgrade_cli(config, dest):
    """rv340 config upgrade"""
    if dest == 'startup':
        strategy = 'replace'
        copy_to_startup = 'config_mgmt.sh copy config-running config-startup'
    else:
        strategy = 'merge'
        copy_to_startup = ''
    if not is_xml(config):
        file1 = open(config, 'r')
        buf = file1.read()
        file1.close()
        template =\
'''output=$(cat <<EOF | confd_cli -s -g admin --noninteractive
configure
%(data)s
commit
exit no-confirm
exit
EOF
)

echo "${output}"

if [ $? != 0 ]; then
    echo 'commit failed'; exit 1;
fi

echo "${output}" | grep 'Aborted:.*not unique.*' > /dev/null
if [ $? = 0 ]; then
    echo 'commit aborted.'; exit 1;
fi

%(copy_to_startup)s; exit 0;

'''
        return template%{'data':buf,
                         'copy_to_startup':copy_to_startup}
    else:
        template =\
'''output=$(cat <<EOF | confd_cli -s -g admin --noninteractive
configure
load %(strategy)s %(filename)s
commit
exit no-confirm
exit
EOF
)

if [ $? != 0 ]; then
    echo 'commit failed'; exit 1;
fi

echo "${output}"
echo "${output}" | grep 'Aborted:.*not unique.*' > /dev/null
if [ $? = 0 ]; then
    echo 'commit aborted.'; exit 1;
fi

%(copy_to_startup)s; exit 0;

'''
        return template%{'strategy':strategy,
                         'filename':config,
                         'copy_to_startup':copy_to_startup}


def is_xml(filename):
    """XML syntax check"""
    try:
        ET.parse(filename)
    except ET.ParseError:
        print("XML ParseError")
        return False
    return True


def _reload_platform(*args):
    """Issues reboot command"""
    reboot_action(*args)
