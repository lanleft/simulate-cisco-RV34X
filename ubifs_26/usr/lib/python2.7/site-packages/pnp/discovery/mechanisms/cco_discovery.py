################################################################################
# Copyright (c) 2015-17 by Cisco Systems, Inc.
# All rights reserved.
#
# Author: Shaurin Desai <shaurdes@cisco.com>
################################################################################
"""CCO Discovery (also known as PnP Connect)

The entry point for this PnP Discovery mechanism is the method: cco_discovery.
This discovery mechanism is different from other PnP Discovery mechanisms in
that it requires a PnP Protocol exchange with the CCO Server (AKA PnP Connect).
Success of this discovery mechanism is determined by the CCO Server response to
the PnP device. If the CCO Server requests the PnP Service Backoff, this is
considered a failure. If another PnP Service request is received (usually
Capability), then CCO Discovery is considered successful and the CCO Server is
stored as the PnP Profile.

Todo:
    * Update CCO Discovery flow to send HELLO to CCO and then sync time
    * Refactor CCO Discovery to reasonably minimize dependency on other modules

"""
import os
from logging import getLogger

import pnp.agent
import pnp.infra.utils.pnp_constants as consts
import pnp.infra.utils.timer as timer
from pnp.infra.network.connection_client import ConnectionInfo
from pnp.infra.network.connection_manager import ConnectionManager
from pnp.infra.network.resolve import timed_url_resolver
from pnp.infra.profile.profile import Profile
from pnp.infra.profile.profile_manager import ProfileManager
from pnp.infra.system.certificate import (get_certificates_location,
                                          get_embedded_certificate)
from pnp.infra.system.clock_sync import ClockSync, set_http_clock_into_system
from pnp.infra.utils.pnp_utils import set_ipv_valid_check_func

logger = getLogger(__name__)


def cco_discovery(protocol=consts.PNP_ADDRTYPE_IPV4):
    """Entry point to the CCO Discovery mechanism.

    Args:
        protocol (str, optional): Preferred protocol for FQDN resolution ('ipv4'
            or 'ipv6'). Defaults to 'ipv4'.

    Returns:
        ConnectionInfo: Connection information for discovered CCO Server
        None: Upon CCO Discovery failure.

    """
    # Skip CCO Discovery if Backoff timer is still active from previous CCO
    # Discovery attempt.
    is_discovery_after_backoff = False
    if timer.timer_exists(consts.CCO_BACKOFF_TIMER):
        time_remaining = timer.get_time_remaining(consts.CCO_BACKOFF_TIMER)
        if time_remaining > 0:
            time_unit = 'seconds'
            if time_remaining >= 86400:  # at least a day
                time_remaining /= 3600
                time_unit = 'hours'
            elif time_remaining >= 3600:  # at least an hour
                time_remaining /= 60
                time_unit = 'minutes'
            logger.debug("Skipping CCO Discovery for about %d %s due to "
                         "backoff", time_remaining, time_unit)
            return None
        else:
            timer.remove_timer(consts.CCO_BACKOFF_TIMER)
            is_discovery_after_backoff = True
            logger.debug("CCO Discovery continues after backoff")
    conn_info = _find_cco_server(protocol, is_discovery_after_backoff)
    if conn_info:
        if conn_info == 'Backoff':
            logger.debug("Backoff request received from CCO Server")
            # Backoff service is responsible for adding 'cco_backoff' timer
            timer.start_timer(consts.CCO_BACKOFF_TIMER)
            return None
        return conn_info
    # No valid connection info found
    logger.debug("CCO Discovery failed")


def _find_cco_server(protocol, is_discovery_after_backoff):
    """Attempts to connect to the CCO Server. If CCO Server is reached, then
    PnP Agent methods will be invoked to handle the PnP Work-Requests coming
    from the CCO Server.

    Args:
        protocol (str): Preferred protocol for FQDN resolution ('ipv4' or
            'ipv6')
        is_discovery_after_backoff (bool) : True if called after backoff
            and clock sync is successful. False otherwise..

    Returns:
        ConnectionInfo: Upon CCO Discovery success
        str: If CCO Server sends a Backoff request, the string "Backoff" is
            returned.
        None: CCO Server is unreachable.

    """

    certificate_directory = get_certificates_location()
    ccoserver_ip = _get_ip(consts.CCO_SERVER_HOSTNAME, protocol)
    if not ccoserver_ip:
        logger.debug("Failed to resolve %s", consts.CCO_SERVER_HOSTNAME)
        return None
    logger.debug("%s resolved to %s", consts.CCO_SERVER_HOSTNAME, ccoserver_ip)
    pnp_trustpool_url = 'http://%s/ca/trustpool' % consts.CCO_SERVER_HOSTNAME
    file_name = pnp_trustpool_url.split('/')[-1]
    cert_path = _set_cert_path(certificate_directory, file_name)
    cco_conn_info = ConnectionInfo(transport=consts.PNP_TRANSTYPE_HTTPS,
                                   address_type=protocol,
                                   address=consts.CCO_SERVER_HOSTNAME,
                                   port=443,
                                   trustpool=pnp_trustpool_url,
                                   discovery_type='cco',
                                   preferred_protocol=protocol)
    # Update conn info if embedded CCO CA certificate is available to use
    if os.path.isfile(cert_path):
        cco_conn_info['cafile'] = cert_path
        cco_conn_info['trustpool'] = None
    is_server_reachable = True
    if not is_discovery_after_backoff:
        # Validate CCO Server connection and communicate through PnP Protocol
        response = ConnectionManager(cco_conn_info).is_valid_set_clock()
        #Error code check
        if response and response['code'] and response['code'] == 200:
            clock_set = response['clock']
            #set clock
            if not set_http_clock_into_system(clock_set):
                logger.error("clock sync: HTTP HEAD failed to set clock")
                clock_set = None
            if not clock_set:
                # Sync system time upon failure, with NTP Servers
                logger.debug("Attempting clock sync through NTP")
                clock_synced = False
                try:
                    clock_synced = ClockSync.set_ntp_server(consts.
                                                            PNP_NTP_SERVER)
                except IOError:
                    logger.debug(ClockSync.error_info)
                if not clock_synced:
                    try:
                        ClockSync.set_ntp_server(consts.POOL_NTP_SERVER)
                    except IOError:
                        logger.debug(ClockSync.error_info)
        else:
            is_server_reachable = False
            logger.debug("Failed to connect to CCO Server")
    if is_server_reachable:
        profile_manager = ProfileManager()
        profile_manager.add_profile(Profile(cco_conn_info, consts.PNP_PROFILE))
        pnp.agent.pre_execute_requests()
        # PnP Agent will stop handling requests after this timer expires
        timer.add_timer(consts.CCO_DISCOVERY_TIMER, time_limit=60, start=True)
        value = pnp.agent.execute_requests(profile_manager)
        if timer.timer_exists(consts.CCO_DISCOVERY_TIMER):
            timer.remove_timer(consts.CCO_DISCOVERY_TIMER)
            profile_manager.terminate_profile(consts.PNP_PROFILE)
        if value == 'Success':
            return cco_conn_info
        if value == '':
            logger.debug("Failed to connect/execute request on CCO server")
        return value



def _get_ip(fqdn, protocol):
    """Returns the first IP address string resolved for the given domain name
    and protocol.

    Args:
        fqdn (string): FQDN to resolve
        protocol (string): Preferred protocol version ('ipv4' or 'ipv6')

    Returns:
         str: Resolved IP address
         None: FQDN cannot be resolved
    """
    resolved_addrs = timed_url_resolver(fqdn, consts.CCO_URL_RESOLVER_TIMER,
                                        protocol)
    if not resolved_addrs:
        return None
    validate_ip = set_ipv_valid_check_func(protocol)
    for addr in resolved_addrs:
        if validate_ip(addr):
            return addr
    return None


def _set_cert_path(cert_dir, filename):
    """This function would 1st look for the presence of the embedded root
    certificate and use that if available. If absence it'd use the input
    file name to compose the certificate's path

    Inputs: cert_dir - the directory where the certificate locates
            filename - the file name used to name the certificate before
                       the .pem extension when the root cert isn't there

    Returns: cert_path - the path including the parent directories & the
                         file name of where the certificate is
    """
    cert_path = get_embedded_certificate(consts.CCO_CERT)
    if not cert_path:
        cert_path = os.path.join(cert_dir, "cco_" + filename + ".pem")
        logger.debug("set certificate path to " + cert_path)
    return cert_path

