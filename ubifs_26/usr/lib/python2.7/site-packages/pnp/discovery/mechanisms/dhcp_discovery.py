################################################################################
# Copyright (c) 2015-17 by Cisco Systems, Inc.
# All rights reserved.
#
# Author: Shaurin Desai <shaurdes@cisco.com>
################################################################################
"""DHCP Discovery through Vendor-specific information from DHCP lease

The entry point for this PnP Discovery mechanism is the method: dhcp_discovery.
This discovery mechanism requires that the Lease Parser API has been implemented
and is available from the pnp_platform library.

"""
import logging
import re
from string import hexdigits
from string import Template

import pnp.infra.utils.pnp_constants as consts
from pnp.discovery.infra.errors import DiscoveryAPIError
from pnp.infra.network.connection_client import ConnectionInfo
from pnp.infra.network.connection_manager import ConnectionManager
from pnp.infra.system.clock_sync import ClockSync

# Platform-Dependent import. If unavailable, DHCP Discovery will fail.
try:
    from pnp.discovery.infra.lease_parser import get_option_strings
except DiscoveryAPIError:
    pass

logger = logging.getLogger(__name__)


def dhcp_discovery(protocol=consts.PNP_ADDRTYPE_IPV4):
    """Uses value from DHCP Option Vendor-specific information to discover PnP
    Server.

    Args:
        protocol (str, optional): Preferred DHCP protocol ('ipv4' or 'ipv6').
            Defaults to 'ipv4'.

    Returns:
        ConnectionInfo: PnP Server connection information extracted from the
            first validated option string. Empty ConnIn
        None: DHCP Discovery failure.

    """
    pnp_dhcp_string_id = '5A'
    next_dhcp_string_id = '6A'
    opt_strings = get_option_strings('vendor-specific-information', protocol)
    hex_set = set(hexdigits+';'+':')
    # Process option strings
    for opt_string in opt_strings:
        opt_string = re.sub(r'[\s"]', '', opt_string)
        # Detect if string is hex encoded and covert
        if all(c in hex_set for c in opt_string):
            opt_string = re.sub(r'[:;\s"]', '', opt_string)
            opt_string = opt_string.decode('hex')
        # Option string does not contain PnP values
        if pnp_dhcp_string_id not in opt_string:
            continue
        opt_string = opt_string.split(pnp_dhcp_string_id)[1]
        opt_string = opt_string.split(next_dhcp_string_id)[0]
        conn_info = _parse_opt_string(opt_string)
        if _connection_info_is_valid(conn_info):
            return conn_info
    # No valid option string found
    logger.debug("DHCP %s Discovery failed", protocol.upper())


def _parse_opt_string(opt_string):
    """Parse option string for connection information.

    Following rules apply:

    1D = PnP DHCP debug on
    1N = PnP DHCP debug off
    token.K = <protocol> 4: HTTP, 5: HTTPS
    token.B = <address type> 1:fqdn, 2:ipv4, 3:ipv6
    token.I = <remote server ip addr>
    token.J = <remote server port>
    token.P = <server jid>
    token.N = <username>
    token.O = <password>
    token.T = <trustpool CA bundle>
    token.Z = <NTP server address>

    Args:
        opt_string (str): Processed PnP DHCP Vendor-specific option string

    Returns:
        ConnInfoDict: PnP Server connection information parsed from opt_string
        None: Error occurred while parsing opt_string

    """
    opt_list = [token for token in opt_string.split(';') if token != '']
    if not opt_list:
        return {}
    connection_info = ConnectionInfo()
    logger.debug('Option string to parse: %s', opt_string)
    # entry[0] is token type, entry[1:] is token value
    for entry in opt_list:
        if entry[0] == '1':
            if entry[1] == 'D':
                root_logger = logging.getLogger('root')
                root_logger.setLevel(logging.DEBUG)
                logger.debug('Option string: %s', opt_string)
            elif entry[1] != 'N':
                logger.error('Invalid Debug Option: %s', entry)
                return None
        elif entry[0] == 'K':
            if entry[1] == '4':
                connection_info['transport'] = consts.PNP_TRANSTYPE_HTTP
            elif entry[1] == '5':
                connection_info['transport'] = consts.PNP_TRANSTYPE_HTTPS
                connection_info['discovery_type'] = 'dhcp'
            elif entry[1] in ('1', '2', '3'):
                logger.error('XMPP transport protocol is not supported')
                return None
            else:
                logger.error('Invalid Protocol: %s', entry)
                return None
        elif entry[0] == 'B':
            if entry[1] == '1':
                connection_info['address_type'] = consts.PNP_ADDRTYPE_HOST
            elif entry[1] == '2':
                connection_info['address_type'] = consts.PNP_ADDRTYPE_IPV4
            elif entry[1] == '3':
                connection_info['address_type'] = consts.PNP_ADDRTYPE_IPV6
            else:
                logger.error('Invalid Address Type: %s', entry)
                return None
        elif entry[0] == 'I':
            connection_info['address'] = entry[1:]
        elif entry[0] == 'J':
            connection_info['port'] = int(entry[1:])
        elif entry[0] == 'P':
            logger.error('XMPP transport protocol is not supported')
            return None
        elif entry[0] == 'N':
            connection_info['user'] = entry[1:]
        elif entry[0] == 'O':
            connection_info['password'] = entry[1:]
        elif entry[0] == 'T':
            connection_info['trustpool'] = entry[1:]
        elif entry[0] == 'Z':
            connection_info['ntp'] = entry[1:]
        else:
            logger.error('Unrecognized Token: %s', entry)
            return None
    logger.debug('****Create trustpool if empty and https')
    if (connection_info['transport'] == consts.PNP_TRANSTYPE_HTTPS and
            not connection_info['trustpool']):
        connection_info['trustpool'] = Template(
                '$path_prefix$address$trustpool_path').substitute(
                path_prefix=consts.PNP_SERVER_TRUSTPOOL_PATH_PREFIX,
                address=connection_info['address'],
                trustpool_path=consts.PNP_SERVER_TRUSTPOOL_PATH)
        logger.debug('added trustpool')
    for key, value in connection_info.items():
        logger.debug('%s is %s', key, value)
    return connection_info


def _connection_info_is_valid(conn_info):
    """Validates connection information.

    Args:
        conn_info (ConnectionInfo): connection info for PnP Server

    Returns:
        bool: True if PnP Server is reachable, False otherwise.
    """
    if conn_info:
        if conn_info['address'] and conn_info['port']:
            # Sync system time with NTP server if address found in option string
            if conn_info['ntp']:
                try:
                    ClockSync.set_ntp_server(conn_info['ntp'])
                except IOError:
                    logger.warning("NTP sync failed")
                    logger.debug(ClockSync.error_info)
            elif (conn_info['address'] and
                  conn_info['transport'] == consts.PNP_TRANSTYPE_HTTPS):
                try:
                    logger.debug('NTP sync server %s', conn_info['address'])
                    ClockSync.set_ntp_server(conn_info['address'])
                except IOError:
                    logger.warning("NTP sync failed from PNP server")
                    logger.debug(ClockSync.error_info)
            if ConnectionManager(conn_info).is_valid():
                return True
    return False

