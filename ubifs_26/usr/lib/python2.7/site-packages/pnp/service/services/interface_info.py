################################################################################
# Copyright (c) 2015-17 by Cisco Systems, Inc.
# All rights reserved.
#
# Author: Andrew Au <aau@cisco.com>
################################################################################
"""PnP Service: Interface-Info
"""
from pnp.infra.system.interface_info_db import IFFState as iff_state
from pnp.infra.system.interface_info_db import InterfaceInfoDb
from pnp.service.api.pnp_service import PnPService


class InterfaceInfo(PnPService):
    """InterfaceInfo queries the platform's network interface info.
    """
    request_type = "physical"
    request_status = "all"
    request_details = None

    def run(self):
        """Generates the Interface-Info Work-Response.
        """
        intf_info = self.request['interfaceInfo']
        if intf_info:
            # intf_into might be None when the Request has no option given
            # in its interfaceInfo element so as to use all default values,
            # i.e. <interfaceInfo />
            self.request_type = intf_info.get('@type', "physical")
            self.request_status = intf_info.get('@status', "all")
            self.request_details = intf_info.get('@details')
        msg = ("InterfaceInfo Service Request rcvd; type: %s, status: %s, "
               "details: %s")
        self.logger.info(msg, self.request_type, self.request_status,
                         self.request_details)
        if self.get_intf_info():
            self.success = True
            log_str = "InterfaceInfo Service Response successfully composed"
            self.logger.info(log_str)
        else:
            # Failure, return success 0 with error code, which should have
            # been set in case-by-case basis before hitting this point.
            self.success = False
            log_str = "Failed to query interface info of type: %s, status: %s"
            self.logger.error(log_str, self.request_type, self.request_status)

    def get_intf_info(self):
        """ Retrieve the list of interface info according to the request
        type & status

        Return:
            bool: True upon successful imageInfo generation. False, otherwise,
                including when InterfaceInfoDb() returns a LookupError exception
        """
        intf_db = None
        try:
            intf_db = InterfaceInfoDb()
        except LookupError:
            err_msg = "LookupError exception in interface info retrieval"
            self.set_error_info(code="INTERNAL", msg=err_msg)
            self.logger.error(err_msg)
            return False

        interface_list = []
        if not intf_db or len(intf_db.get_keys()) == 0:
            log_str = "No interface returned"
            self.logger.info(log_str)
        else:
            db_items = intf_db.get_items()
            for intf_name, intf_info in db_items.iteritems():
                intf = intf_info
                # Convert the interface status to either 'up' or 'down'
                # according to its Linux UP and operstate status, i.e. RUNNING
                status = int(intf.get('status')) & iff_state.IFF_UP
                is_up = (status != 0 and
                         intf.get('operstate').find('down') == -1)
                if is_up:
                    intf['status'] = 'up'
                else:
                    intf['status'] = 'down'

                # Call is_intf_to_report() to determine if this interface is
                # to be reported according to the interface type & status
                # specified in the Request
                if self.is_intf_to_report(intf) is False:
                    continue

                interface = dict()
                interface['name'] = intf_name
                interface['status'] = intf.get('status')
                if is_up:
                    interface['protocol'] = 'up'
                    interface['ok'] = 'YES'
                else:
                    interface['protocol'] = 'down'
                    interface['ok'] = 'NO'
                interface['address'] = {}
                if intf.get('ipv4'):
                    interface['address']['ipv4'] = intf.get('ipv4')
                if intf.get('ipv6'):
                    interface['address']['ipv6'] = intf.get('ipv6')
                interface['macAddress'] = intf.get('macAddress')
                interface['method'] = 'unset'
                interface_list.append(interface)
        self.response['interfaceList'] = {}
        self.response['interfaceList']['interface'] = interface_list
        log_str = "# of interfaces with info retrieved = %s" % \
                  str(len(interface_list))
        self.logger.info(log_str)
        return True

    def is_intf_to_report(self, intf_info):
        """Examine the given interface's type & status to determine if it is to
        be included in the Response according the wanted type & status specified
        in the Request

        Args:
            intf_info (dict): a particular interface to be filtered

        Return:
            bool: True, if it's to be included. False, otherwise.
        """
        if (self.request_type != "all" and
                self.request_type != intf_info.get('type')):
            return False

        if (self.request_status != "all" and
                self.request_status != intf_info.get('status')):
            return False

        return True
