################################################################################
# Copyright (c) 2015-17 by Cisco Systems, Inc.
# All rights reserved.
#
# Author: Shaurin Desai <shaurdes@cisco.com>
################################################################################
"""PnP Service: Redirection

Redirection updates a profile configuration in order to redirect it to another
PnP Server.

Notes:
    This service is the main PnP Service used by PnP Connect.

Todo:
    * check HELLO before switching to Redirection profile
    * support "reconnect" schema element
    * improve error info reporting
    * add support for primary/backup Profile

"""
import os

import pnp.infra.system.certificate as server_auth
from pnp.infra.network.connection_client import ConnectionInfo
from pnp.infra.network.connection_manager import ConnectionManager
from pnp.infra.system.vbond import VBond
from pnp.infra.system.wlc import WLC
from pnp.infra.utils.pnp_constants import PNP_PROFILE
from pnp.infra.utils.pnp_utils import (compose_url, get_ipv_preferred,
                                       get_server_addr, terminate_agent,
                                       update_pnp_config)
from pnp.service.action import ServiceAction
from pnp.service.api.pnp_service import PnPService


class Redirection(PnPService):
    """PnP Service: Redirection
    """

    redir_conn_info = dict()
    profile_name = PNP_PROFILE

    def run(self):
        """Generates the Redirection Work-Response."""
        ipv_prefer = get_ipv_preferred()
        if not ipv_prefer:
            self.logger.error("failed to get preferred IP version")
            self.set_error_info(code="REQ", msg="Error redirection service")
            return None
        redir = self.request['redirection']
        ip_addr_dict = dict()
        ip_addr_dict['primary'] = get_server_addr(redir['primary-server'],
                                                  ipv_prefer)
        if redir.get('backup-server'):
            ip_addr_dict['backup'] = get_server_addr(redir['backup-server'],
                                                     ipv_prefer)
        if not len(ip_addr_dict):
            return None

        result = False
        # Handle redirection according to controller type
        controller_type = redir.get('@controller-type')
        if controller_type == 'wlc':
            result = WLC.update_config_platform(ip_addr_dict, ipv_prefer)
            if result:
                action_args = [self.logger, 'WLC']
                self.action = ServiceAction(_redirection_action, 'wlc-redirect',
                                            *action_args)
            else:
                self.set_error_info(msg='Failed to perform WLC redirection')
        elif controller_type == 'vbond':
            result = self._vbond_redirection()
        elif attempt_redir_func(self.find_redirection_server, ip_addr_dict,
                                self.logger):
            result = self.store_redirection_profile()
            if not result:
                self.set_error_info(code='FAIL_PROFILE_CONFIG',
                                    msg='Failed to store redirection profile')
        else:
            self.set_error_info(code='INTERNAL',
                                msg='Error in Redirection service')
        # Determine service run success or failure
        if result:
            self.success = 1
        else:
            self.success = 0
            self.logger.error("Error in redirection service")

    def find_redirection_server(self, _, address, address_type, server,
                                validate=True):
        """Extracts the Redirection Server connection details from the
        Work-Request and validates them, while the server IP address
        has been extracted already & provided as input here

        Args:
            _ (logging.Logger): this logger is passed in so as to unify the
                interface for both find_rediction_server and
                update_config_platform so that both can be called as a function
                vector from attempt_redir_func()
            address (str): the redirection server address to be connected to
            address_type(str): the IP version type of this given address
            server (str): value 'primary-server' or 'backup-server'
            validate (bool, optional): If True, redirection server connection is
                validated with HELLO. Defaults to True.

        Modifies: self.redir_conn_info

        Returns:
            bool: True, if connection details are validated. False, otherwise.

        """
        server_elem = self.request['redirection'][server]
        protocol = server_elem.get('protocol', 'http')
        port = int(server_elem['server-address'].get('port', 80))
        # Handle callback is True once multiple profiles are supported
        if self.request['redirection'].get('callback'):
            pass

        self.redir_conn_info.update({'transport': protocol, 'address': address,
                                     'port': port})
        if address_type:
            self.redir_conn_info['address_type'] = address_type
            self.logger.debug("conn_info in find_redirection_server: %s",
                              str(self.redir_conn_info))
        if any(not self.redir_conn_info[key] for key in ('transport', 'address',
                                                         'port')):
            self.logger.error("Redirection Server connection information "
                              "missing from work-request.")
            self.set_error_info(code='REQ', msg="Error redirection service")
            return False

        redirect_url = compose_url(protocol, address, port)
        self.logger.info('Redirection Server Found: %s', redirect_url)

        # Set cafile for https connection
        if protocol == 'https':
            if not server_elem.get('encryption'):
                err_str = "No remote cert information for HTTPS connection"
                self.logger.error(err_str)
                self.set_error_info(code="REQ", msg=err_str)
                return False
            encryption = server_elem.get('encryption')
            remotecert = encryption.get('remotecert')
            self.logger.info("HTTPS Remotecert %s", remotecert)
            if not remotecert:
                err_str = "No Remote Cert Information For HTTPS Connection"
                self.logger.error(err_str)
                self.set_error_info(code="REQ", msg=err_str)
                return False
            cert_location = server_auth.get_certificates_location('trustpoint')
            cafile = os.path.join(cert_location, remotecert)
            if not os.path.isfile(cafile):
                err_str = ("Remote cert is not installed already for HTTPS "
                           "connection")
                self.logger.error(err_str)
                self.set_error_info(code="REQ", msg=err_str)
                return False
            self.logger.debug("Remote cert installed for HTTPS connection. "
                              "Setting connection info cafile as %s", cafile)
            self.redir_conn_info['cafile'] = cafile

            self.logger.debug("Redirection connection info %s",
                              str(self.redir_conn_info))
        if validate:
            conn_info = ConnectionInfo(**self.redir_conn_info)
            if ConnectionManager(conn_info).is_valid():
                self.logger.debug("Redirection Server is reachable")
                return True
        self.logger.warning("Redirection Server is unreachable")
        self.set_error_info(severity='WARNING', code='REQ',
                            msg="Redirection Server Unreachable")
        return not validate

    def store_redirection_profile(self):
        """Stores the redirection profile using the connection details found in
        the redir_conn_info attribute.

        Returns:
            bool: True, if redirection profile is stored successfully. False,
                otherwise.

        """
        if update_pnp_config(self.redir_conn_info):
            self.logger.debug("Redirection profile stored successfully.")
            return True
        else:
            self.logger.error("Failed to store Redirection Profile.")
            return False

    def _vbond_redirection(self):
        """Handles vBond controller-type redirection. Implementation only
        supports primary-server (PnP Connect restricts backup-server from being
        used).

        Modifies:
            action: upon redirection success, action is set to terminate Agent
            error_info: if there are any warning/error messages to report

        Returns:
            bool: True if redirection is successful, False otherwise.

        """
        org_name = self.request['redirection'].get('organization-name', '')
        server_elem = self.request['redirection']['primary-server']
        protocol = server_elem['protocol']
        address = server_elem['server-address'].get('ipv4')
        if not address:
            address = server_elem['server-address'].get('host')
            if not address:
                address = server_elem['server-address'].get('ipv6', '')
                addr_type = 'ipv6'
            else:
                addr_type = 'host'
        else:
            addr_type = 'ipv4'
        port = int(server_elem['server-address'].get('port', '12346'))
        encrypt_elem = server_elem.get('encryption')
        if encrypt_elem:
            cert = encrypt_elem.get('remotecert', '')
        else:
            cert = ''
        # If remotecert is specified, construct absolute path to local file
        if cert:
            cert_location = server_auth.get_certificates_location('trustpoint')
            cert = os.path.join(cert_location, cert)
            if not os.path.isfile(cert):
                err = 'vBond remote cert not found: %s' % cert
                self.logger.error(err)
                self.set_error_info(code='FAIL_REMOTE_CERT_CREATE', msg=err)
                return False
        self.logger.info("Attempting redirection to vBond through: "
                         "Organization Name: %s, Protocol: %s, "
                         "Address: (%s, %s), Port: %d, Remote Cert: %s",
                         org_name, protocol, addr_type, address, port, cert)
        result = VBond.update_vbond_config(org_name, protocol,
                                           (addr_type, address), port, cert)
        if result:
            action_args = [self.logger, 'vBond']
            self.action = ServiceAction(_redirection_action,
                                        'vbond-redirect',
                                        *action_args)
        elif VBond.error_info:
            msg_sev = VBond.error_info.severity
            err_msg = VBond.error_info.message
            code = VBond.error_info.code
            self.set_error_info(severity=msg_sev, msg=err_msg, code=code)
        return result


def _redirection_action(logger, controller_type):
    logger.info('Stopping PnP now that %s Redirection has completed.',
                controller_type)
    terminate_agent()


def attempt_redir_func(redir_func, addr_dict, logger):
    """This method attempts to run the provided redirection function with the
    valid server addresses found, which include those of types ipv4 and ipv6.
    Especially when both are present, it will try with the more preferred addr
    1st, then the less preferred one.

    Args:
        redir_func (:obj:'function'): this is the function/method to be executed
            with each valid address
        addr_dict (dict): a list of the retrieved server addresses in tuple with
            its 1st element as the address & its type specified in its 2nd
            element, e.g. ("1.2.3.4", "ipv4")
        logger (logging.Logger): logger

    Return:
        bool: True/False as the success/failure result of the function execution

    """
    for ipaddr, iptype in addr_dict['primary']:
        if redir_func(logger, ipaddr, iptype, 'primary-server'):
            return True
    if addr_dict.get('backup'):
        for ipaddr, iptype in addr_dict['backup']:
            if redir_func(logger, ipaddr, iptype, 'backup-server'):
                return True
    # Store first primary address if both are unreachable
    ipaddr, iptype = addr_dict['primary'][0]
    return redir_func(logger, ipaddr, iptype, 'primary-server', validate=False)
