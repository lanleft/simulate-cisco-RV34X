################################################################################
# Copyright (c) 2015-17 by Cisco Systems, Inc.
# All rights reserved.
#
# Author: Shaurin Desai <shaurdes@cisco.com>
################################################################################
"""PnP Services API

PnPService serves as the interface between the PnP Agent and PnP Services.
PnP Services are implemented as classes and MUST inherit from the PnPService
class. PnPService subclasses MUST implement the "run" abstractmethod, which
should result in a populated response attribute.

Note:
    File names for the service must match the service name, substituting hyphens
    (-) for underscores (_). This means that each service must be implemented in
    its own file.

    For example implementations, refer to submodules defined in the module
    pnp.service.services.

Todo:
    * Add Service API support for serviceLog

See Also:
    https://wiki.cisco.com/x/CKI2
"""
import json
import logging
from abc import ABCMeta, abstractmethod

from pnp.infra.exec_log import ExecLogInfo
from pnp.service.action import ServiceAction
from pnp.service.errors import ServiceErrorInfo


class PnPService(object):
    """PnPService serves as the base class for all PnP Service implementations.

    Inheriting classes must implement the "run" method.
    """
    __metaclass__ = ABCMeta

    #: (ServiceAction): Routine to perform upon PnP Handshake completion. Should
    # be set according to the PnP Service result.
    action = None

    #: (str): PnP Service name (extracted from Work-Request XML namespace)
    name = None

    #: (Profile): PnP Profile instance that is handling the service
    profile = None

    #: (dict): PnP Work-Request payload. Request is populated by the PnP Agent
    # after Service class instantiation. This attribute contains a JSON
    # dictionary representation of the PnP Work-Request XML payload. To see how
    # PnP maps XML to JSON, refer to the module pnp.infra.xmlparser (there is no
    # 1-to-1 mapping between XML and JSON, so PnP follows its own convention).
    request = None

    #: (ResponseDict): PnP Work-Response payload. Response could be an empty
    # dictionary, depending on which Service is requested. This object will only
    # contain service-specific data (success, correlator, error info, and
    # service log are all EXCLUDED and will be dropped).
    response = None

    #: (int): Represents the result of the Service run (value is 1 if Service
    # ran successfully, 0 otherwise).
    success = None

    @abstractmethod
    def run(self):
        """Populates the PnPService attributes based off the execution of the
        requested PnP Service.

        Modifies: self.success, self.response, self.action
        """
        pass

    @property
    def logger(self):
        """Logger for services.

        Returns:
            logging.Logger: Logger for inheriting Service class to use.
        """
        return self._api_logger.getChild(self.name)

    def set_error_info(self, severity='ERROR', code='INTERNAL', msg=''):
        """Sets error information for a service run. It is possible for a
        service to run successfully and still generate error or warning
        information.

        Modifies: self.error_info

        Args:
            severity (str, optional): Info severity (one of ERROR or WARNING).
                Defaults to ERROR.
            code (str, optional): One of the error codes found in the
                pnp.service.errors module. Defaults to INTERNAL.
            msg (str, optional): Human readable message describing the error or
                warning that will be sent to the PnP Server (very important for
                debugging). Defaults to '<Service> execution encountered an
                issue'.

        """
        if not msg:
            msg = "%s execution encountered an issue" % self.name
        self.error_info = ServiceErrorInfo(self.name, severity.upper(),
                                           code.upper(), msg)

    __action = None
    #: (ServiceErrorInfo): Service error information. When a service has no
    # error information to report, this attribute should remain None
    __error_info = None
    __name = None
    __pnp_profile = None
    __request = None
    # PnP Work-Request payload (JSON string <json.loads> sent from PnP Agent)
    # When payload is empty (e.g. capability service), __raw_request is {}.
    # Due to this behavior, it is not reliable to use 'if not __raw_request' in
    # a flow control statement
    __raw_request = None
    __response = None
    # PnP Work-Response payload (JSON string <json.dumps>)
    __raw_response = None
    __success = None

    # logger for use by PnPService API
    _api_logger = logging.getLogger('pnp.service.PnPService')

    # exec log info is saved in this attribute below
    __exec_log = ExecLogInfo()

    def __init__(self, name_, pnp_profile_):
        """Inheriting classes should NOT define an __init__ method.

        Args:
            name_ (str): PnP Service name
            pnp_profile_ (Profile): PnP Profile instance
        """
        # replace hyphen with underscore to map service name to service
        # implementation file name
        self.__name = name_.replace('-', '_')
        self.__pnp_profile = pnp_profile_

    @property
    def action(self):  # pylint: disable=function-redefined
        """If action has not been set, then a default ServiceAction instance is
        returned.

        Returns:
            <ServiceAction> instance
        """
        if not self.__raw_request:
            raise UnboundLocalError("Cannot get action without a request")
        elif not self.__action:
            return ServiceAction()
        return self.__action

    @action.setter
    def action(self, action_):
        """Validates action_ input is of <type 'ServiceAction'>, ensures action
        was not already run, and ensures action is only set once.

        Args:
            action_ -- <ServiceAction> instance

        Raises:
            RuntimeError
                if set more than once
            TypeError
                if ServiceAction instance is not provided
            ValueError
                if ServiceAction instance has already been executed
        """
        if self.__action:
            raise RuntimeError("PnPService.action can only be set once")
        elif not isinstance(action_, ServiceAction):
            self.__action = None
            raise TypeError("Expected <type 'ServiceAction'>; got %s instead",
                            type(action_))
        elif hasattr(action_, 'result'):
            raise ValueError("PnPService.action cannot store an already "
                             "'called' ServiceAction instance")
        self.__action = action_

    @property
    def error_info(self):
        """ServiceErrorInfo: Provides error information for a failed service
        execution. Value should be set by PnP Service using self.set_error_info
        upon service failure. If not set by the Service, default values will be
        provided.

        Raises:
            UnboundLocalError: If setting any value before the request property
                has been set.
            TypeError: If setting a value that is not of type ServiceErrorInfo.

        """
        if self.__raw_request is None:
            raise UnboundLocalError("Cannot get error_info without a request")
        # Set service error for failed service execution (if not already set)
        elif not self.success and not self.__error_info:
            self.__error_info = ServiceErrorInfo(self.name, 'ERROR', 'INTERNAL',
                                                 'Internal Error')
        return self.__error_info

    @error_info.setter
    def error_info(self, service_error_info):  # pylint: disable=missing-docstring
        if not isinstance(service_error_info, ServiceErrorInfo):
            raise TypeError("error_info requires a ServiceErrorInfo instance")
        self.__error_info = service_error_info

    @property
    def request(self):  # pylint: disable=function-redefined
        """dict: PnP Work-Request payload. Request is populated by the PnP
        Agent after Service class instantiation.

        This attribute contains a JSON dictionary representation of the PnP
        Work-Request XML payload. To see how PnP maps XML to JSON, refer to
        pnp.infra.xmlparser (there is no 1-to-1 mapping between XML and JSON,
        so PnP follows its own convention).

        Raises:
            RuntimeError: If setting request more than once.
            TypeError: If setting a non-string value.

        """
        if self.__raw_request is None:
            raise UnboundLocalError('request not set')
        elif self.__request == 'Bad':
            return None
        return self.__request

    @request.setter
    def request(self, request_):  # pylint: disable=missing-docstring
        if self.__raw_request is not None:
            raise RuntimeError('request can only be set once')
        if not isinstance(request_, basestring):
            raise TypeError('request requires a str or unicode instance')
        self.__raw_request = request_
        try:
            self.__request = json.loads(self.__raw_request)
            self._api_logger.debug('request set: %s', self.__request)
        except (TypeError, ValueError) as err:
            args = (self.__class__.__name__, err)
            self._api_logger.exception('%s request failed: %r', *args)
            self.__error_info = ServiceErrorInfo(self.name, 'error', 'REQ',
                                                 repr(err))
            self.__request = 'Bad'
            self.__success = 0

    @property
    def response(self):  # pylint: disable=function-redefined
        """(ResponseDict): PnP Work-Response payload. Response could be an empty
        dictionary, depending on which Service is requested. This object will
        only contain service-specific data (success, correlator, error info, and
        service log are all EXCLUDED and will be dropped).

        Raises:
            TypeError: If setting a non-dict value.
            ValueError: If storing "success" or "errorInfo" element.

        """
        if self.__raw_request is None:
            raise UnboundLocalError("Cannot get response without a request")
        elif self.__request == 'Bad' or self.__response is None:
            self.__response = ResponseDict()
        self.__raw_response = json.dumps(self.__response)
        return self.__response

    @response.setter
    def response(self, response_):  # pylint: disable=missing-docstring
        if not isinstance(response_, dict):
            raise TypeError("response requires a dict")
        elif 'success' in response_:
            raise ValueError("response should not contain 'success' key")
        elif 'errorInfo' in response_:
            raise ValueError("response should not contain 'errorInfo' key")
        # overwrite existing response dictionary
        if not isinstance(response_, ResponseDict):
            response_ = ResponseDict(response_)
        self.__response = response_

    @property
    def success(self):  # pylint: disable=function-redefined
        """int: Represents the result of the Service run (value should be 1 if
        Service ran successfully, 0 otherwise).
        """
        if self.__success:
            return 1
        return 0

    @success.setter
    def success(self, success_):
        if success_:
            self.__success = 1
        else:
            self.__success = 0

    @property
    def name(self):  # pylint: disable=function-redefined
        """str: PnP Service name (extracted from Work-Request XML namespace)"""
        return self.__name

    @property
    def profile(self):  # pylint: disable=function-redefined
        """Profile: PnP Profile instance that is handling this service"""
        return self.__pnp_profile

    @property
    def exec_output_log(self):
        """Provides exec output log info to a service run.
        It raises the UnboundLocalError exception when this exec output log is
        retrieved at a time when no Service Request has been received, although
        this isn't supposed to happen.
        """
        if self.__raw_request is None:
            raise UnboundLocalError("Cannot get exec_output_log without "
                                    "a request")
        return self.__exec_log.output_log

    @exec_output_log.setter
    def exec_output_log(self, log_info):
        """This is the setter for exec_output_log"""
        self.__exec_log.output_log = log_info

    @property
    def exec_error_log(self):
        """Provides exec error log info to a service run.
        It raises the UnboundLocalError exception when this exec output log is
        retrieved at a time when no Service Request has been received, although
        this isn't supposed to happen.
        """
        if self.__raw_request is None:
            raise UnboundLocalError("Cannot get exec_error_log without "
                                    "a request")
        return self.__exec_log.error_log

    @exec_error_log.setter
    def exec_error_log(self, log_info):
        """This is the setter for exec_error_log"""
        self.__exec_log.error_log = log_info


class ResponseDict(dict):
    """Dictionary subtype used to hold PnP Service response data. Restricts user
    from setting values for reserved PnP Service response keywords (success,
    correlator, errorInfo, serviceLog).
    """
    def __setitem__(self, key, value):
        if key not in ('success', 'correlator', 'errorInfo', 'serviceLog'):
            dict.__setitem__(self, key, value)
