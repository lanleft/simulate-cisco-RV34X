################################################################################
# Copyright (c) 2015-17 by Cisco Systems, Inc.
# All rights reserved.
#
# Author: Shaurin Desai <shaurdes@cisco.com>
################################################################################
"""Timers

This module manages timers within a single process. A timer can be set with a
time length to specify when it will expire. Another use for a timer is to
measure the length of time elapsed since the timer started.

"""
import sys
import time
from collections import namedtuple
from logging import getLogger
from multiprocessing import Process, Value

logger = getLogger(__name__)

_timers = dict()


def timer_exists(timer_name):
    """Returns True if specified timer has already been added.

    Args:
        timer_name (str): timer identifier

    Returns:
        bool: True if specified timer has already been added, False if timer
            does not exist

    """
    return timer_name in _timers


def add_timer(timer_name, time_limit=None, start=False):
    """Adds a timer identified by timer_name. If time_limit is specified, then
    timer will stop after that length of time. If start is set to True, then the
    timer will be started.

    Args:
        timer_name (str): Timer identifier
        time_limit (int, optional): Time length in seconds before timer is
            considered to be expired. If not provided, timer will not expire.
        start (bool, optional): Start timer immediately after adding it.

    Returns:
        bool: True if timer was successfully added, False if timer
            initialization failed or if a timer with the same name already
            exists

    """
    # Input validation for timer_name
    if not timer_name:
        logger.debug('Invalid timer_name provided')
        return False
    if timer_name in _timers:
        logger.debug('Timer with name "%s" already exists', timer_name)
        return False
    # Input validation for time_limit
    try:
        if time_limit is not None and int(time_limit) < 0:
            logger.debug('Time length cannot have a negative value')
            return False
    except (TypeError, ValueError) as error_str:
        logger.debug('Unable to set expiration time for timer "%s": %s',
                     timer_name, repr(error_str))
        return False
    # Initiate and store timer process
    counter = Value('d', 0.0, lock=True)
    timer_proc = Process(target=_sleep_func, args=(time_limit, counter))
    timerinfo = namedtuple('TimerInfo', ['timer_proc', 'time_limit', 'counter'])
    _timers[timer_name] = timerinfo(timer_proc, time_limit, counter)
    # Optional start timer
    if start:
        if not start_timer(timer_name):
            logger.debug('Failed to start timer: "%s"', timer_name)
            return False
    return True


def timer_status(timer_name, debug=False):
    """Returns status of specified timer.

    Args:
        timer_name (str): Timer identifier
        debug (bool, optional): Enable debug log messages. Defaults to False.

    Returns:
        str: Timer status. One of the following values:
            'Expired' specified timer has expired,
            'Running' specified timer has not expired,
            'Not Found' timer was not added, or
            'Not Started' timer was not started.

    """
    if timer_name not in _timers:
        status = 'Not Found'
    elif _timers[timer_name].timer_proc.is_alive():
        status = 'Running'
    elif _timers[timer_name].timer_proc.exitcode is None:
        status = 'Not Started'
    else:
        status = 'Expired'
    if debug:
        logger.debug('Timer Status for "%s": %s', timer_name, status)
    return status


def start_timer(timer_name):
    """Starts the specified timer

    Args:
        timer_name (str): Timer identifier

    Returns:
        bool: True if timer started successfully, False otherwise.

    """
    state = timer_status(timer_name, debug=True)
    if state == 'Not Started':
        logger.debug('Starting timer "%s"', timer_name)
        _timers[timer_name].timer_proc.start()
        return True
    else:
        return False


def get_time_remaining(timer_name):
    """Returns approximated amount of time (seconds) until timer expires.

    Args:
        timer_name (str): Timer identifier

    Returns:
        int: Approximate time remaining (in seconds) until specified timer
            expires. If timer was not started or expiration time was not
            provided, returns a negative value.
    """
    state = timer_status(timer_name, debug=True)
    if state == 'Running':
        if _timers[timer_name].time_limit is None:
            logger.debug('Timer with name "%s" has no expiration', timer_name)
            return -1
        time_remaining = _timers[timer_name].time_limit
        with _timers[timer_name].counter.get_lock():
            elapsed = round(_timers[timer_name].counter.value)
        time_remaining -= elapsed
    elif state == 'Expired':
        time_remaining = 0
    else:
        return -1
    return int(time_remaining)


def get_time_elapsed(timer_name):
    """Returns amount of time (seconds) since specified timer was started.

    Args:
        timer_name (str): Timer identifier

    Returns:
        int: Time elapsed (in seconds) for specified timer.

    """
    state = timer_status(timer_name, debug=True)
    if state in ('Expired', 'Running'):
        with _timers[timer_name].counter.get_lock():
            elapsed = int(round(_timers[timer_name].counter.value))
        return elapsed
    else:
        return 0


def remove_timer(timer_name):
    """Removes specified timer from set of timers

    Args:
        timer_name (str): Timer identifier

    Returns:
        bool: True if specified timer was successfully removed, False otherwise.

    """
    state = timer_status(timer_name, debug=True)
    if state == 'Not Found':
        return False
    else:
        if state != 'Not Started':
            _timers[timer_name].timer_proc.terminate()
        _timers.pop(timer_name)
        logger.debug('Removed timer: "%s"', timer_name)
        return True


def _sleep_func(timerlen, counter):
    """Target function for the timer process.

    Args:
        timerlen (int): Time length of timer. If None, indefinite timer.
        counter (Value): Maintains time elapsed counter.

    """
    if timerlen is None:
        timerlen = sys.maxint
    sleeplen = 1
    if timerlen >= 86400:  # 1 day
        sleeplen = 3600 # 1 hour
    elif timerlen >= 3600:  # 1 hour
        sleeplen = 60  # 1 minute
    while timerlen > 0:
        if sleeplen > timerlen:
            sleeplen = timerlen
        time.sleep(sleeplen)
        with counter.get_lock():
            counter.value += sleeplen
        timerlen -= sleeplen
