################################################################################
# Copyright (c) 2015-17 by Cisco Systems, Inc.
# All rights reserved.
#
# Author: Shaurin Desai <shaurdes@cisco.com>
################################################################################
"""Utility functions for pnp

Todo:
    * split into smaller files, grouped by functionality
    * implement _generate_device_info
    * implement download_file utility with corresponding _download_<proto>
      functions which pnp_platform can overload as needed

"""
import json
import os
import re
import signal
import socket
from ConfigParser import NoOptionError, NoSectionError, SafeConfigParser
from logging import getLogger
from random import randint
from time import gmtime, sleep, strftime, time
from urlparse import urlparse

import pnp.infra.utils.pnp_constants as consts
from pnp.infra.network.connection_client import ConnectionInfo
from pnp.infra.system.device import Device
from pnp.infra.system.event import Event
from pnp.infra.utils.pnp_file_paths import filepaths

logger = getLogger(__name__)


def get_pnp_config():
    """This function reads the config file for the PnP config and returns it
    back.

    Returns:
        SafeConfigParser: The read PnP Config.

    """
    config = SafeConfigParser()
    if not config.read(filepaths['config']['pnp']):
        logger.error("PnP config not found")
        return None
    return config


def profile_exists():
    """Returns a pnp_cfg filled with the config data from the PnP profile if
    it's configured and its transport field is present filled.

    Returns:
         ConnectionInfo: pnp_cfg filled with config data in the valid PnP
                         profile found
         None: if pnp_config is not found

    """
    return read_pnp_config(True)


def read_pnp_config(check_transport=False):
    """Loads the PnP Profile config the pnp_config file and returns a connection
    data dictionary

    Returns:
        ConnectionInfo: Dictionary populated with connection data loaded from
            pnp_config

    """
    config = get_pnp_config()
    if not config:
        return None
    pnp_profile = 'Profile ' + consts.PNP_PROFILE
    if check_transport:
        try:
            transport_info = config.get(pnp_profile, 'transport')
            if not transport_info:
                logger.debug('No valid PnP config read; no transport info')
                return None
            elif not transport_info.split():
                logger.debug('No valid PnP config read; null content')
                return None
        except (NoOptionError, NoSectionError, KeyError) as err:
            logger.debug('No valid PnP config read; exception: %s', repr(err))
            return None
    try:
        conn_data = {
            'transport': config.get(pnp_profile, 'transport'),
            'address': config.get(pnp_profile, 'address'),
            'port': config.get(pnp_profile, 'port'),
            'cafile': config.get(pnp_profile, 'cafile'),
            'created_by': config.get(pnp_profile, 'created_by'),
            'preferred_protocol': config.get(pnp_profile, 'preferred_protocol')
        }
    except (NoOptionError, NoSectionError):
        logger.exception('PnP config file is malformed')
        return None
    connection_info = ConnectionInfo(**conn_data)
    logger.debug('PnP config read: %s', connection_info)
    return connection_info


def update_pnp_config(new_config):
    """Updates the PnP Profile data in the pnp_config file with the provided
    data.

    Args:
        new_config (dict): New pnp config data

    Returns:
        bool: True if pnp config updated successfully, False otherwise.

    """
    config = get_pnp_config()
    if not config:
        return None
    # Determine updated PnP config values
    pnp_profile = 'Profile ' + consts.PNP_PROFILE
    try:
        old_transport = config.get(pnp_profile, 'transport')
        transport = new_config.get('transport', old_transport)
        address = new_config.get('address', config.get(pnp_profile, 'address'))
        port = new_config.get('port', config.get(pnp_profile, 'port'))
        cafile = new_config.get('cafile', config.get(pnp_profile, 'cafile'))
        old_created_by = config.get(pnp_profile, 'created_by')
        created_by = new_config.get('created_by', old_created_by)
        old_preferred = config.get(pnp_profile, 'preferred_protocol')
        preferred_protocol = new_config.get('preferred_protocol', old_preferred)
        modified = new_config.get('modified', 'true')
    except (NoOptionError, NoSectionError):
        logger.exception('PnP config file is malformed')
        return False
    # Store updated PnP config values
    config.set(pnp_profile, 'transport', transport)
    config.set(pnp_profile, 'address', address)
    config.set(pnp_profile, 'port', str(port))
    config.set(pnp_profile, 'cafile', cafile)
    config.set(pnp_profile, 'created_by', created_by)
    config.set(pnp_profile, 'preferred_protocol', preferred_protocol)
    config.set(pnp_profile, 'modified', modified)
    try:
        with open(filepaths['config']['pnp'], 'w') as config_file:
            config.write(config_file)
    except IOError:
        logger.exception('Failed to update PnP config')
        return False
    if not Event.profile_updated(pnp_profile, new_config):
        logger.debug(Event.error_info)
    return True


def load_platform_info():
    """Loads platform information. Legacy method is to load from platform.json
    file. New implementation relies on the Device API to generate the platform
    info.

    Returns:
        dict: Platform information dictionary.

    """
    if hasattr(Device, 'get_device_info'):
        return Device.get_device_info()
    elif consts.PNP_PLATFORM == 'PI':
        return _generate_device_info()
    else:
        # legacy method to load platform information
        return _load_platform_info()


def _load_platform_info():
    """Loads platform json file using filepath string from config file and
    returns platform info dictionary.

    Returns:
        dict: Platform Info loaded from platform.json file
        None: Upon error

    Note:
        This API has been deprecated from version 1.5.0 onwards. pnp_platform
        module replaces this functionality with Device API implementation.
    """
    config = SafeConfigParser()
    config.read(filepaths['config']['platform'])
    pnp_profile = 'Profile ' + consts.PNP_PROFILE
    try:
        platform_file = config.get(pnp_profile, 'platform')
    except (NoSectionError, NoOptionError):
        logger.exception("Platform config file is missing")
        return None
    try:
        with open(platform_file) as f:
            platform = json.load(f)
    except (IOError, AttributeError, ValueError):
        logger.exception("Failed to load platform info")
        return None
    return platform


def _generate_device_info():
    """Generates fake device information. Only to be used by PI Agent.
    """
    if consts.PNP_PLATFORM != 'PI':
        return {}
    udi_str = "PID:{pid},VID:{vid},SN:{sn}"
    platform_id = 'POSIX-PI'
    version_id = 'V01'
    serial_num = _random_with_n_digits(11)
    udi = udi_str.format(pid=platform_id, vid=version_id, sn=serial_num)
    return {'udi': udi, 'imageInfo': {'versionString': consts.PNP_VERSION}}


def terminate_agent():
    """Prepares the PnP Agent for graceful shutdown and then terminates the
    Agent. This includes removing/updating files and killing the Agent process.
    """
    # store pid from pid file before removing the file
    with open(filepaths['log']['pid']) as pid_file:
        pid = pid_file.read().strip()
    os.remove(filepaths['log']['pid'])
    # write stop time to pnp status file
    with open(filepaths['data']['status'], 'r') as pnp_status_file:
        pnp_status = json.loads(pnp_status_file.read())
    with open(filepaths['data']['status'], 'w') as pnp_status_file:
        last_start_time = strftime("%H:%M:%S %b %d", gmtime(time()))
        pnp_status['agent']['last_start_time'] = last_start_time
        pnp_status_file.write(json.dumps(pnp_status))
    logger.info('Stopping PnP Agent')
    # notify platform of agent termination
    Event.agent_terminating()
    # kill Agent process and spawned child processes
    os.killpg(os.getpgid(int(pid)), signal.SIGKILL)
    # Wait for termination by sleeping for some time
    sleep(2)


def is_valid_ipv4_address(address):
    """Check whether a string is a valid IPv4 address

    Args:
        address (str): IPv4 address to validate

    Returns:
        bool: True if address is a valid IPv4 address, False otherwise.

    """
    if not address:
        return False
    try:
        socket.inet_pton(socket.AF_INET, str(address))
    except AttributeError:  # no inet_pton here, sorry
        try:
            socket.inet_aton(address)
        except socket.error:
            return False
    except socket.error:  # not a valid address
        return False
    return True


def is_valid_ipv6_address(address):
    """Check whether a string is a valid IPv6 address

    Args:
        address (str): IPv6 address to validate

    Returns:
        bool: True if address is a valid IPv6 address, False otherwise.
    """
    if not address:
        return False
    try:
        socket.inet_pton(socket.AF_INET6, str(address))
    except socket.error:  # not a valid address
        return False
    return True


def is_valid_hostname(address):
    """Check whether a string is a valid hostname

    Args:
        address (str): Hostname address

    Returns:
        bool: True if address is a valid hostname, False otherwise.

    """
    if not address:
        return False
    if len(address) > 255:
        return False
    # FQDN allowed to end in a single dot
    # Removing dot to determine whether all other characters are legal below
    if address.endswith("."):
        address = address[:-1]
    disallowed = re.compile(r"[^A-Z\d-]", re.IGNORECASE)

    return all(  # Split by labels and verify individually
        (label and len(label) <= 63  # length is within proper range
         and not label.startswith("-") and not label.endswith("-")
         and not disallowed.search(label))  # contains only legal characters
        for label in address.split("."))


def is_valid_ip_address(address):
    """Check whether a string is a valid ip address

    Args:
        address (str): IP Address

    Returns:
        bool: True if IP Address is valid format, False otherwise.

    """
    return is_valid_ipv4_address(address) or is_valid_ipv6_address(address)


def set_ipv_valid_check_func(ip_type):
    """This function returns the proper version specific IP addr validation
    function back to the caller

    Args:
        ip_type (str): IP addr type for which the valid check function is to be
            set

    Returns:
        IP addr validation function for the given IP addr type
    """
    if ip_type == consts.PNP_ADDRTYPE_IPV4:
        return is_valid_ipv4_address
    elif ip_type == consts.PNP_ADDRTYPE_IPV6:
        return is_valid_ipv6_address
    else:
        return is_valid_ip_address


def compose_url(protocol, address, port):
    """Compose PNP server address

    Args:
        protocol (str): Transport protocol
        address (str): IP Address or FQDN
        port (int): Port number

    Returns:
        str: url of PnP Server
        None: failed to compose url

    """
    if consts.IPV6_ENABLED and is_valid_ipv6_address(address):
        server_address = '%s://[%s]:%s/' % (protocol, address, port)
    elif is_valid_ipv4_address(address) or address:
        server_address = '%s://%s:%s/' % (protocol, address, port)
    else:
        logger.error('Error: Failed to compose server url')
        return None
    return server_address


def set_pnp_config_ipv_preferred(address):
    """This function seeks to set the preferred IP version in the PnP
    config file to the type of the given address input. This setting
    is done if & only if this input is of either IPv4 or IPv6.

    Args:
        address (str):the IP version type of this address is taken as the new
            preferred IP version

    Returns:
         bool: True if set successfully, False otherwise.

    """
    config = get_pnp_config()
    if not config:
        return False

    if not address:
        return False
    elif is_valid_ipv4_address(address):
        pref_version = consts.PNP_ADDRTYPE_IPV4
    elif is_valid_ipv6_address(address):
        pref_version = consts.PNP_ADDRTYPE_IPV6
    else:   # hostname
        return False
    pnp_profile = 'Profile ' + consts.PNP_PROFILE
    try:
        with open(filepaths['config']['pnp'], 'w') as config_file:
            config.set(pnp_profile, 'preferred_protocol', pref_version)
            config.write(config_file)
    except IOError:
        logger.exception("Failed to set preferred IP version into config")
        return False

    logger.info("preferred IP version set to %s", pref_version)
    return True


def get_ipv_preferred():
    """This function seeks to retrieve the preferred IP version type from the
    PnP config and return it back to the caller.

    Returns:
         str: retrieved IP version type if successfully retrieved. Empty string
            otherwise.
    """
    config = get_pnp_config()
    if not config:
        logger.error("PnP config file is malformed/unready")
        return ''
    pnp_profile = 'Profile ' + consts.PNP_PROFILE
    try:
        ipv_prefer = config.get(pnp_profile, 'preferred_protocol')
        if ipv_prefer not in (consts.PNP_ADDRTYPE_IPV4,
                              consts.PNP_ADDRTYPE_IPV6):
            logger.error("preferred IP version in config is invalid")
            return ''
        logger.info("preferred IP version retrieved: %s", ipv_prefer)
        return ipv_prefer
    except (NoOptionError, NoSectionError):
        logger.exception('PnP config file is malformed/unready')
        return ''


def get_less_preferred_ipv_type(preferred):
    """This function takes a preferred IP version type, i.e. ipv4 or ipv6 &
    then returns back the other version type as the less preferred type

    Args:
         preferred (str): the preferred IP version type

    Returns:
        str: the less preferred IP version
    """
    if preferred == consts.PNP_ADDRTYPE_IPV4:
        return consts.PNP_ADDRTYPE_IPV6
    else:
        return consts.PNP_ADDRTYPE_IPV4


def get_server_addr(primary_srv, ipv_pref):
    """This function retrieves from the given server object the server
    addresses according to the given preferred IP version type. It'll
    add the preferred address retrieved to the start of the result
    list of tuples. Then, the less preferred address retrieved. Then,
    any provided host name.

    Args:
        primary_srv (dict): the server object in which the server's addresses &
            host name would have been saved
        ipv_pref (str): the preferred IP version type

    Returns:
        list(tuple): list of tuples of retrieved addresses in the preferred
            order, with the tuple's 1st element as the address/host and 2nd
             element to specify its type, e.g. ('1.2.3.4', 'ipv4')

    """
    addr_result = []
    address = primary_srv['server-address'].get(ipv_pref)
    if address:
        logger.info("server address retrieved: %s; type: %s",
                    address, ipv_pref)
        addr_result.append((address, ipv_pref))

    ipv_less_prefer = get_less_preferred_ipv_type(ipv_pref)
    address = primary_srv['server-address'].get(ipv_less_prefer)
    if address:
        logger.info("server address retrieved: %s; type: %s",
                    address, ipv_less_prefer)
        addr_result.append((address, ipv_less_prefer))

    address = primary_srv['server-address'].get(consts.PNP_ADDRTYPE_HOST)
    if address:
        logger.info("server address retrieved: %s; type: %s", address,
                    consts.PNP_ADDRTYPE_HOST)
        addr_result.append((address, consts.PNP_ADDRTYPE_HOST))
    return addr_result


def retrieve_string_in_quote(string):
    """This function seeks to retrieve the string content embraced within
    quotes, either single or double and returns the found string inside to the
    caller.

    Args:
        string (str): the input string possibly embraced by some quotes

    Returns:
         str: the string content within quotes if present the original string if
            it's not embraced by any quotes

    """
    # handle string if it's embraced within single quotes
    result = re.search("\'(.+?)\'", string)
    if result:
        return result.group(0)[1:-1]
    # handle string if it's embraced within double quotes
    result = re.search('\"(.+?)\"', string)
    if result:
        return result.group(0)[1:-1]
    return None


def obscure_password_behind_keyword(msg, pattern):
    """This function seeks to obscure any included password in a message that
    is behind the given pattern

    Args:
        msg (str): the message in which the password is to be obscured
        pattern (str): the pattern in the msg behind which a password would be
            present

    Returns:
        str: the resulting msg with its password obscured if present otherwise
            the original msg if absent
    """
    found = re.search(pattern, msg)
    if not found:
        return None
    start = msg.find(found.group(0)) + len(found.group(0))
    # find the password substring behind the given pattern
    password = retrieve_string_in_quote(msg[start:])
    if not password:
        return msg
    # replace the found password with the exact # of "*"
    result = msg.replace(password, '*'*len(password))
    return result


def obscure_password_in_msg(msg):
    """This function seeks to obscure any included password in a message that
    could be behind 'pwd=' or '@pwd:'

    Args:
        msg (str): the message in which the password is to be obscured

    Returns:
         str: the resulting msg with its password obscured if present

    """
    # obscure the password stated behind "pwd =" with any # of spaces within
    result = obscure_password_behind_keyword(msg, r"pwd(\s*?)=(\s*?)")
    if result:
        return result
    # obscure the password stated behind "'@pwd':" with any # of spaces within
    result = obscure_password_behind_keyword(msg, r"\'\@pwd\'(\s*?):(\s*?)")
    if result:
        return result
    return msg


def _random_with_n_digits(n):
    range_start = 10**(n-1)
    range_end = (10**n)-1
    return randint(range_start, range_end)


def parse_url(url):
    """This function parses a given input URL for the scheme, network
    location and path specified in it to return back to its function
    caller in the list format. Any of these mentioned element(s) being
    absent in the URL will be represented as None in the returned list.

    Arg:
        URL - an input argument in the URL or file path format

    Returns:
        tuple (scheme, network-location, file-path) where
            scheme (str): the scheme/protocol specified, e.g. http
            network-location (str): network location like an IPv4
                address with port #
            file-path (str): file path at the given network location
    """
    try:
        result = urlparse(url)
        ret_value = result.scheme, result.netloc, result.path
    except (AttributeError, TypeError):
        ret_value = None, None, None

    logger.debug("URL parsed: scheme %s, network-loc %s, path %s",
                 ret_value[0], ret_value[1], ret_value[2])
    return ret_value
