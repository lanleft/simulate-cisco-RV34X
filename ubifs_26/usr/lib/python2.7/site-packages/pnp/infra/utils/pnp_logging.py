################################################################################
# Copyright (c) 2015-17 by Cisco Systems, Inc.
# All rights reserved.
#
# Author: Shaurin Desai <shaurdes@cisco.com>
################################################################################
"""PnP Logging

Set up logging for pnp module.

"""
import logging
import logging.handlers
import stat
from ConfigParser import NoOptionError, NoSectionError
from logging.config import fileConfig
from os import chmod

from pnp.infra.utils.pnp_constants import LOG_BACKUP_COUNT, LOG_MAX_BYTES
from pnp.infra.utils.pnp_file_paths import filepaths

logging_initiated = False


class PnPGroupWriteRotatingFileHandler(logging.handlers.RotatingFileHandler):
    """PnP Rotating Log handler.

    This handler will create the pnp.log file at the configured file path,
    enable rotating files upon reaching maximum size, and set log file
    permissions to all user writeable
    """
    # construct path to pnp log file based off configured file paths
    try:
        log_path = filepaths['log']['pnp']
    except KeyError:
        log_path = ''

    def __init__(self, name=None, mode='a', maxBytes=LOG_MAX_BYTES,
                 backupCount=LOG_BACKUP_COUNT):
        log_args = {
            'mode': mode,
            'maxBytes': maxBytes,
            'backupCount': backupCount
        }
        if not name:
            name = self.log_path
        super(PnPGroupWriteRotatingFileHandler, self).__init__(name, **log_args)

    def doRollover(self):
        """Override base class method to make the new log file group writeable.
        """
        # Rotate the file first
        logging.handlers.RotatingFileHandler.doRollover(self)

        # Add group write to the current permissions
        permission = (stat.S_IWOTH | stat.S_IROTH | stat.S_IRUSR |
                      stat.S_IWUSR | stat.S_IRGRP | stat.S_IWGRP)
        chmod(self.log_path, permission)


class PnPErrorFileHandler(PnPGroupWriteRotatingFileHandler):
    """PnP Error Log handler.

    This handler will create a single log file to record any Error logs.
    """
    try:
        log_path = filepaths['log']['error']
    except KeyError:
        log_path = ''

    def __init__(self):
        log_args = {
            'name': self.log_path,
            'mode': 'a',
            'maxBytes': LOG_MAX_BYTES,
            'backupCount': LOG_BACKUP_COUNT
        }
        super(PnPErrorFileHandler, self).__init__(**log_args)


def initiate_logging():
    """Initiates logging for the pnp module, and if possible, the pnp_platform
    module.
    """
    # Load pnp logging module from pnp logging configuration
    pnp_logging_config = filepaths['config']['logging']
    try:
        fileConfig(pnp_logging_config)
    except (IOError, NoOptionError, NoSectionError, ValueError, TypeError,
            ImportError):
        # default logging config will be used instead.
        logging.basicConfig()
    platform_logging_config = ''
    # Find path to platform logging configuration
    try:
        platform_logging_config = filepaths['config']['platform_logging']
    except KeyError:
        logging.debug('platform_logging option missing from Config section of '
                      'platform file paths configuration file')
    # Load platform logging configuration
    if platform_logging_config:
        try:
            fileConfig(platform_logging_config, disable_existing_loggers=False)
        except IOError:
            logging.debug('platform logging configuration file not found')
        except (NoOptionError, NoSectionError, ValueError, TypeError,
                ImportError):
            logging.exception("platform logging configuration is malformed")
    global logging_initiated  # pylint: disable=global-statement
    logging_initiated = True


def enable_debug_log_level(logger_name):
    """Sets the logging level to DEBUG for specified logger. If 'all' is
     specified, then the root logger level will change.
    """
    logging.getLogger(logger_name).setLevel(logging.DEBUG)


if __name__ == '__main__':
    initiate_logging()
