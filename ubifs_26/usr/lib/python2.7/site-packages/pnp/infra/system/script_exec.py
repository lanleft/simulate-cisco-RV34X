################################################################################
# Copyright (c) 2017 by Cisco Systems, Inc.
# All rights reserved.
#
# Author: Andrew Au <aau@cisco.com>
################################################################################
"""Script execution implementation used by the Script Service support
This file provides the implementation for script execution.

"""
import os
import subprocess
import sys
import urllib2
from httplib import BadStatusLine as HttpBadStatusLine
from logging import getLogger
from socket import timeout as socket_timeout
from threading import Timer

from pnp.infra.api.pnp_infra import PnPInfra
from pnp.infra.utils.file_utils import (read_from_remote_file,
                                        write_data_to_file)
from pnp.infra.utils.pnp_utils import parse_url


# Set a file size limit in bytes for scripts & result data than allow a
# limitless amount for safety; use the limit used in IOS, i.e.
# IFS_COPY_BUFFER_SIZE or 64K
default_filesize_limit = 64*1024


python_script_preamble = ["#!/usr/bin/env python",
                          "#!/usr/local/bin/env python",
                          "#!/usr/bin/python", "#!/usr/local/bin/python"]
tcl_script_preamble = "##tcl-install-script"

logger = getLogger(__name__)


try:
    from pnp_platform.infra.script_exec import ScriptExec # pylint: disable=wrong-import-position
    if not issubclass(ScriptExec, PnPInfra):
        raise ImportError("ScriptExec implementation not conform "
                          "to PnPInfra API")
except ImportError:
    class ScriptExec(PnPInfra):
        """PnP Script exec API
        These are the methods for executing script as supported in the Script
        Service
        """

        @classmethod
        def python_script_execute(cls, pscript_file, wait_time, args=""):
            """This function executes the given python script with the provided
            argument together.

            Args:
                pscript_file (str): the absolute path to where the script
                    file is located
                wait_time (str): max wait time for the script to complete
                    executing
                args (str, optional): the input arguments for running with the
                    script

            Returns:
                int: the script execution's return code
            """
            cmdlist = [sys.executable]
            cmdlist.append(pscript_file)
            cmdlist.extend(args.split())
            logger.debug("command line: %s", ' '.join(cmdlist))
            rc = -1
            output_log = None
            err = None
            try:
                subproc = subprocess.Popen(cmdlist, stdout=subprocess.PIPE,
                                           stderr=subprocess.PIPE,
                                           stdin=subprocess.PIPE)
                kill = lambda process: process.kill()
                wait_timer = Timer(int(wait_time), kill, args=[subproc])
                try:
                    logger.debug("max time for script to run: %s secs",
                                 wait_time)
                    wait_timer.start()
                    output_log, err = subproc.communicate()
                    rc = subproc.poll()
                except (OSError, IOError) as ex:
                    logger.error("Script execution failed upon exception "
                                 + repr(ex))
                finally:
                    wait_timer.cancel()
            except OSError:
                logger.error("Script execution failed upon exception")

            cls.exec_output_log = output_log
            cls.exec_error_log = err
            return rc

        @classmethod
        def tcl_script_execute(cls, tscript_file, wait_time, args=""): #pylint: disable=unused-argument
            """This function executes the given TCL script with the provided
            argument together.

            Args:
                tscript_file (str): the absolute path to where the script
                    file is located
                wait_time (str): max wait time for the script to complete
                    executing
                args (str, optional): the input arguments for running with the
                    script

            Returns:
                int: the script execution's return code
            """
            cmdlist = ["tclsh"]
            cmdlist.append(tscript_file)
            cmdlist.extend(args.split())
            logger.debug("command line: %s", ' '.join(cmdlist))
            rc = -1
            output_log = None
            err = None
            try:
                subproc = subprocess.Popen(cmdlist, stdout=subprocess.PIPE,
                                           stderr=subprocess.PIPE,
                                           stdin=subprocess.PIPE)
                kill = lambda process: process.kill()
                wait_timer = Timer(int(wait_time), kill, args=[subproc])
                try:
                    logger.debug("max time for script to run: %s secs",
                                 wait_time)
                    wait_timer.start()
                    output_log, err = subproc.communicate()
                    rc = subproc.poll()
                except (OSError, IOError) as ex:
                    logger.error("Script execution failed upon exception "
                                 + repr(ex))
                finally:
                    wait_timer.cancel()
            except OSError:
                logger.error("Script execution failed upon exception")

            cls.exec_output_log = output_log
            cls.exec_error_log = err
            return rc

        @classmethod
        def script_download(cls, script_path, archive_file):
            """This function downloads the script from the given absolute path
            and saves it into the given archive file path.

            Args:
                script_path (str): the absolute path to where the script
                    file is to be downloaded from
                archive_file (str): the absolute path to where this
                    downloaded file is locally archived

            Output:
                the script file being downloaded into a local archive

            Returns:
                (str) the download's error cause if any; None if
                    successful
            """
            if not archive_file:
                logger.error("Internal error to archive script file")
                return "INTERNAL"

            scheme, netloc, path = parse_url(script_path)
            if not path:
                logger.error("location element missing file path")
                return "REQ"

            ret = None
            if not scheme and not netloc:
                # Case: local file system
                try:
                    src_file = open(script_path, 'r')
                    data = src_file.read(default_filesize_limit)
                    src_file.close()
                except (IOError, OSError) as ex:
                    logger.error("Failed to retrieve script from local file"
                                 "system, err: " + repr(ex))
                    ret = "FILE_READ_FAILED"
            elif netloc and scheme in ['http', 'https']:
                # Case: remote file system
                try:
                    # This API call supports both IPv4 and v6
                    data, ret = read_from_remote_file(script_path,
                                                      default_filesize_limit)
                except (OSError, urllib2.URLError, urllib2.HTTPError,
                        HttpBadStatusLine, socket_timeout) as ex:
                    logger.error("Failed to download from remote file system, "
                                 "err: " + repr(ex))
                    ret = "FILE_READ_FAILED"
            else:
                # Case: all others, not supported, including 'flash0:',
                # 'disk0:', 'usb', etc., by default. If supported, the
                # implementations to handle them need to be provided by the PD
                logger.error("Unsupported file system given for downloading "
                             "script")
                ret = "FILE_OPEN_FAILED"
            if ret:
                # Return upon error
                logger.error("Failed to download: " + ret)
                if ret == "HTTPS failed":
                    # convert https failure to standard error type
                    ret = "FILE_OPEN_FAILED"
                return ret

            # Remove old archive 1st
            try:
                if os.path.isfile(archive_file):
                    os.remove(archive_file)
            except OSError:
                logger.error("Failed to remove old script archive locally")
                return "INTERNAL"
            # Write script into archive
            try:
                write_data_to_file(data, archive_file)
            except IOError:
                logger.error("Failed to archive script file locally")
                return "INTERNAL"
            logger.info("Script downloaded successfully to: " + archive_file)
            return None


def script_execute(stype, script, mwait, cmd_args):
    """This function calls the corresponding execute function to run the
    given script according to its given type.

    Args:
        stype (str): script type
        script (str): the absolute path to where the script file is located
        mwait (str): max wait time for the script to complete executing
        cmd_args (str or None): the input arguments for running with the script

    Returns:
        tuple (return value, error, output log) where
            return_value (int): the script execution's return code
            error (str): the script execution's generated stderrdata
                retrieved from ScriptExec.exec_error_log
            output log (str): the script execution's generated stdoutdata
                retrieved from ScriptExec.exec_output_log
    """
    if stype == 'python':
        if cmd_args:
            rc = ScriptExec.python_script_execute(script, mwait,
                                                  args=cmd_args)
        else:
            rc = ScriptExec.python_script_execute(script, mwait)
        return (rc, ScriptExec.exec_error_log,
                ScriptExec.exec_output_log)
    elif stype == 'tcl':
        if cmd_args:
            rc = ScriptExec.tcl_script_execute(script, mwait,
                                               args=cmd_args)
        else:
            rc = ScriptExec.tcl_script_execute(script, mwait)
        return (rc, ScriptExec.exec_error_log,
                ScriptExec.exec_output_log)
    else:
        return (-1, "Unsupported", None)


def script_get_results(result_file):
    """This function reads the result data from the given result file and
    return its content back in a string. Only local file system is supported
    here.  If on any platform, remote ones will be, such implementation
    has to be proviced in platform_pnp.infra.device.

    Args:
        result_file (str): the file into which the script has already
            saved its results for retrieval

    Returns:
        (str) contents of this result file; None upon empty contents
            or failures
    """
    logger.debug("Retrieving script result data from file: " + result_file)
    try:
        rfile = open(result_file, 'r')
        data = rfile.read(default_filesize_limit)
        rfile.close()
    except (IOError, OSError) as ex:
        logger.error("Failed to read results from local file %s, err: %s",
                     result_file, repr(ex))
        return None
    return data


def parse_script_preamble(script_path):
    """This function reads a script file given in the path argument and
    parses its 1st file for its preamble to check against those for python
    & TCL. If so found, it'll return the script type back; otherwise None.

    Args:
        script_path (str): local absolute path to the script's location

    Returns:
        (str) either one of the following:
            'python': if the python preamble is found in the script file's
                1st line
            'tcl': if the TCL preamble is found in the script file's
                1st line
            None: if no known preamble can be found
    """
    try:
        script_file = file(script_path)
    except IOError:
        logger.error("Nonexistent file to parse for preamble")
        return None

    first_line = script_file.readline()
    script_file.close()

    if first_line.strip('\n') in python_script_preamble:
        return 'python'
    elif first_line.strip('\n') == tcl_script_preamble:
        return 'tcl'
    else:
        return None


def script_download(script_path, archive_file):
    """This function downloads the script from the given absolute path
    and saves it into the given archive file path.

    Args:
        script_path (str): the absolute path to where the script
            file is to be downloaded from
        archive_file (str): the absolute path to where this
            downloaded file is locally archived

    Output:
        the script file being downloaded into a local archive

    Returns:
        (str) the download's error cause if any; None if
            successful
    """
    return ScriptExec.script_download(script_path, archive_file)
